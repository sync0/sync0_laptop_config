/*
* Copyright (C) 2011 Google Inc. All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are
* met:
*
*     * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above
* copyright notice, this list of conditions and the following disclaimer
* in the documentation and/or other materials provided with the
* distribution.
*     * Neither the name of Google Inc. nor the names of its
* contributors may be used to endorse or promote products derived from
* this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/**
 * @fileoverview Contains all the DB specific functions for the clock app.
 */

/**
 * The default name space for the clock application.
 */
var clockApp = clockApp || {};

/**
 * Variable to contain a reference to the background.html page.
 */
var bg = chrome.extension.getBackgroundPage();

/**
 * The database name space for the clock app.
 */
clockApp.db = {};

/**
 * @const Table name for user world clocks.
 */
clockApp.db.USER_CLOCK = 'clocks_selected_for_display';

/**
 * @const Table name for user created alarms.
 */
clockApp.db.USER_ALARMS = 'clock_alarm';

/**
 * The database object.
 */
clockApp.db.db = null;

/* According to HTML5 specs the recommended default size is 5 MB,
 * @link {http://www.w3.org/TR/webdatabase/#disk-space}.
 */
try {
  if (window.openDatabase) {
    clockApp.db.db = openDatabase('ClockApp', '1.0', 'Clock Data', 5120 * 1024);
    if (!clockApp.db.db) {
      console.log('Error Opening the database Db object is null.');
    }
  } else {
    console.log('Error Opening the database.');
  }
} catch (err) {
    clockApp.db.db = null;
    console.log('Error Opening the database ' + err);
}

/**
 * Checks and creates the DB tables when application is initialized.
 */
clockApp.db.intializeDBTables = function() {
  clockApp.db.db.transaction(function(tx) {
    tx.executeSql('CREATE TABLE IF NOT EXISTS ' + clockApp.db.USER_CLOCK +
                 ' (id INTEGER PRIMARY KEY ASC , cityName TEXT,' +
                 ' priority TEXT,timeZone TEXT' + 'lastsyncTS REAL)',
                  [], function(result) {});
    tx.executeSql('CREATE TABLE IF NOT EXISTS ' + clockApp.db.USER_ALARMS +
                 ' (id INTEGER PRIMARY KEY ASC, time TEXT,' +
                 'isRepeat BOOLEAN, repeat TEXT, sound TEXT,' +
                 'isEnabled BOOLEAN, alarmType TEXT)', [], function(result) {}
    );
  });
};

/**
 * Retrieves all the clocks from the table clocks_selected_for_display in
 *   the order of the priority. The call back method passed here must be able to
 *   process the List of user clocks that are generated by this method.
 * @param {Function} callbackMethod Method to be invoked.
 */
clockApp.db.getAllClocks = function(callbackMethod) {
  clockApp.db.db.transaction(function(tx) {
    tx.executeSql('SELECT id, cityName, timeZone FROM ' +
            clockApp.db.USER_CLOCK + ' order by priority asc ', [],
        function(tx, result) {
          callbackMethod(clockApp.db.getClocksList(result));
        },
        function(tx, error) {
          console.log('Failed to retrieve clocks from database - ' +
              error.message);
        });
  });
};

/**
 * Inserts a new clock into the table clocks_selected_for_display.
 * @param {UserClock} clockData The object containing user selected clock data.
 */
clockApp.db.insertClock = function(clockData) {
  clockApp.db.db.transaction(function(tx) {
      tx.executeSql('INSERT INTO ' + clockApp.db.USER_CLOCK + ' (' +
                   'cityName, timeZone , priority) VALUES (?, ?, ?)',
          [clockData.cityName, clockData.timeZone, clockData.priority]);
  });
};

/**
 * Returns the current maximum priority value.
 * @param {Function} callback Method to be invoked.
 */
clockApp.db.getMaxPriority = function(callback) {
  clockApp.db.db.transaction(function(tx) {
      tx.executeSql('SELECT max(priority) from ' + clockApp.db.USER_CLOCK + ' ',
          [],
          function(tx, result) {
            var row = result.rows.item(0);
            if (callback) {
              callback(row['max(priority)']);
            }
          });
  });
};

/**
 * Increments the priority value of the selected city to maximum priority.
 * @param {String} priority Value with which to update priority.
 * @param {String} cityName City for which priority is to be updated.
 */
clockApp.db.incrementPriority = function(priority, cityName) {
  clockApp.db.db.transaction(function(tx) {
    tx.executeSql("UPDATE clocks_selected_for_display SET priority='" +
                 priority + "' where cityName='" + cityName + "'");
  });
};

/**
 * Deletes clocks from DB.
 * @param {UserClock} clockData Object containing clock to be deleted.
 * @param {Function} callback Method to be invoked back.
 */
clockApp.db.deleteClock = function(clockData, callback) {
  clockApp.db.db.transaction(function(tx) {
      tx.executeSql('DELETE FROM ' + clockApp.db.USER_CLOCK + ' where' +
                    ' cityName =?', [clockData.cityName],
          function(result) {},
          function(tx, error) {
            console.log('error ' + error.message);
            console.log('Unable to delete clock for' +
                    ' city name ' + clockData.cityName);
          });
  });
  if (callback) {
    clockApp.db.getAllClocks(callback);
  }
};

/**
 * Class representing User clock data.
 * @param {String} cityName Name of the city.
 * @param {String} timeZone city time zone.
 * @param {Number} priority Ordering priority.
 * @constructor
 */
function UserClock(cityName, timeZone, priority) {
  this.id;
  this.cityName = cityName;
  this.timeZone = timeZone;
  this.priority = priority || 0;
}

/**
 * Returns a list of available clocks.
 * @param {UserClock} result User clocks from DB.
 * @return {Array} userClocksList List of user selected clocks.
 */
clockApp.db.getClocksList = function(result) {
  var userClocksList = [];
  for (var i = 0, j = result.rows.length; i < j; ++i) {
    var row = result.rows.item(i);
    var userClock = new UserClock();
    userClock.id = row['id'];
    userClock.cityName = row['cityName'];
    userClock.timeZone = row['timeZone'];
    userClocksList.push(userClock);
  }
  return userClocksList;
};

/**
 * Returns the list of all alarms for the user; creates the clock_alarm
 * table if not present.
 * @param {Function} callback Function to be invoked after execution of method.
 */
clockApp.db.getAllAlarms = function(callback) {
  clockApp.db.db.transaction(function(tx) {
    tx.executeSql('SELECT * FROM ' + clockApp.db.USER_ALARMS, [],
        function(tx, result) {
          // console.log('select query result: clock_alarm ', result);
          if (result.rows.length > 0) {
            if (callback) {
              callback(result);
            }
        } else {
            // TODO vikram check if we can get rid of bg calls from db code
            bg.ac.isUpdated = false;
            bg.ac.setNewAlarm();
        }
    });
  });
};

/**
 * Inserts a new alarm into the table clock_alarm.
 * @param {Object} alarmData The alarm meta data object.
 * @param {Function} callback Function to be called on successful
 *   execution of the method.
 */
clockApp.db.insertAlarm = function(alarmData, callback) {
  clockApp.db.db.transaction(function(tx) {
    tx.executeSql("SELECT * FROM clock_alarm where time='" +
                 alarmData.alarmTime + "' and alarmType='alarm'", [],
      function(tx, result) {
        if (result.rows.length > 0) {
          clockApp.db.updateAlarmData(result, alarmData, tx, callback);
        } else {
          tx.executeSql('INSERT INTO ' + clockApp.db.USER_ALARMS + ' (time,' +
                       'isRepeat,' + 'repeat,sound,isEnabled,alarmType) ' +
                       'VALUES (?, ?, ?, ?, ?,?)',
              [(alarmData.alarmTime).toString(), alarmData.isRepeat,
                 alarmData.repeatDays, alarmData.sound, alarmData.isEnabled,
                 alarmData.alarmType]);
          bg.ac.isUpdated = true;
          if (callback) {
            callback();
          }
        }
      }, function(tx, error) {
        console.log('Error in insert statement');
      });
  });
};

/**
 * Inserts a new snooze type alarm into the table clock_alarm.
 * @param {Object} alarmData The alarm meta data object.
 * @param {Function} callback Function to be called on successful
 *   execution of the method.
 */
clockApp.db.insertSnooze = function(alarmData, callback) {
  clockApp.db.db.transaction(function(tx) {
    tx.executeSql('INSERT INTO ' + clockApp.db.USER_ALARMS + ' (time,' +
                 'isRepeat,repeat,sound,isEnabled,alarmType)' +
                 'VALUES (?, ?, ?, ?, ?,?)',
        [(alarmData.alarmTime).toString(), false,
            alarmData.repeatDays, alarmData.sound, alarmData.isEnabled,
            alarmData.alarmType]);
    bg.ac.isUpdated = true;
    if (callback) {
      callback();
    }
  });
};

/**
 * Updates an alarm in the table clock_alarm when user tries to insert an alarm
 *   for which a similar alarm is already present in the table.
 * @param {Object} dbAlarm The alarm meta data object from the database.
 * @param {Object} newAlarm The alarm meta data object set by user.
 * @param {Object} tx The db transaction object.
 * @param {Function} callback Function to be called on successful
 *   execution of the method.
 */
clockApp.db.updateAlarmData = function(dbAlarm, newAlarm, tx, callback) {
  var row = dbAlarm.rows.item(0);
  var id = row['id'];
  var newRepeat = new Array();
  if (newAlarm.isRepeat) {
    var oldRepeat = row['repeat'].split(',');
    newRepeat = newRepeat.concat(oldRepeat);
    for (var i = 0; i < newAlarm.repeatDays.length; i++) {
      var found = false;
      for (var j = 0; j < newRepeat.length; j++) {
        if (newRepeat[j] == newAlarm.repeatDays[i]) {
          found = true;
        }
      }
      if (!found) {
        newRepeat.push(newAlarm.repeatDays[i]);
      }
    }
  } else {
    newRepeat.push(newAlarm.repeatDays);
  }
  tx.executeSql("UPDATE clock_alarm SET isRepeat='" + newAlarm.isRepeat +
    "',repeat='" + newRepeat + "',sound='" + newAlarm.sound +
    "',isEnabled='true' WHERE id=" + id);
  bg.ac.isUpdated = true;
  if (callback) {
    callback();
  }
};

/**
 * Enable/disable the alarm.
 * @param {String} id The alarm id of the alarm.
 * @param {String} flag determines whether to enable or disable the alarm.
 * @param {Function} callback Function to be called on successful
 *   execution of the method.
 */
clockApp.db.enableDisableAlarm = function(id, flag, callback) {
  clockApp.db.db.transaction(function(tx) {
    tx.executeSql("UPDATE clock_alarm SET isEnabled='" + flag +
                 "' where id=" + id);
    bg.ac.isUpdated = true;
    if (callback) {
      callback();
    }
  });
};

/**
 * Updates an alarm in the table clock_alarm when alarm is saved in edit mode.
 * @param {Object} alarmData The alarm meta data object set by user.
 * @param {Function} callback Function to be called on successful
 *   execution of the method.
 */
clockApp.db.updateAlarm = function(alarmData, callback) {
  clockApp.db.db.transaction(function(tx) {
    tx.executeSql("UPDATE clock_alarm SET time='" + alarmData.alarmTime +
                 "',isRepeat='" + alarmData.isRepeat + "',repeat='" +
                 alarmData.repeatDays + "',sound='" + alarmData.sound +
                 "',isEnabled='true' where id=" + alarmData.id, [],
        function(result) {
          bg.ac.isUpdated = true;
          if (callback) {
            callback();
          }
        },
        function(tx, error) {
          console.log('error in clockApp.db.updateAlarm', alarmData.id);
          bg.ac.isUpdated = true;
          if (callback) {
            callback();
          }
        });
  });
};

/**
 * Deletes the alarms from the table clock_alarm.
 * @param {String} alarmIds - primary keys of the alarms to be deleted.
 * @param {Function} callback Function to be called on successful
 *   execution of the method.
 */
clockApp.db.deleteAlarm = function(alarmIds, callback) {
  clockApp.db.db.transaction(function(tx) {
     tx.executeSql('DELETE FROM ' + clockApp.db.USER_ALARMS + ' WHERE id in(' +
                  alarmIds + ')',
         [],
         function(result) {
           bg.ac.isUpdated = true;
           if (callback) {
             callback();
           }
         },
         function(tx, error) {
           console.log('error in clockApp.db.deleteAlarms', alarmIds);
         });
  });
};
