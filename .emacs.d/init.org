#   This program is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the
#   Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.

#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.

#   You should have received a copy of the GNU General Public License
#   along with this program. If not, see <http://www.gnu.org/licenses/>.

#+TITLE: Emacs Settings
#+AUTHOR: sync0
#+EMAIL: cantorlunae@gmail.com
# Visualization settings.
#+STARTUP: noindent  showall showstars
# Local Variables:
# eval: (orwell-mode) 
# End:
# Necessary to tangle this file.
#+PROPERTY: header-args :tangle yes
* Reminders
- In Org mode, ~<s + tab~ creates a code block. To make it executable,
  add the words ~emacs-lisp~.
- The location for hunspell dictionaries should be in /usr/share/hunspell.
* Initialization
** Scratch Message
The following code changes the welcoming message displayed by Emacs in the
/scratch/ buffer. I have the begining of Karl Marx and Friedrich Engels'
/Manifest der Kommunistischen Partei/.
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message ";; Ein Gespenst geht um in Europa – das Gespenst des Kommunismus. 
;; Alle Mächte des alten Europa haben sich zu einer heiligen Hetzjagd 
;; gegen dies Gespenst verbündet, 
;; der Papst und der Czar, 
;; Metternich und Guizot, 
;; französische Radikale und deutsche Polizisten.

;; Wo ist die Oppositionspartei, 
;; die nicht von ihren regierenden Gegnern als kommunistisch verschrieen worden wäre, 
;; wo die Oppositionspartei, 
;; die den fortgeschritteneren Oppositionsleuten sowohl, 
;; wie ihren reaktionären Gegnern den brandmarkenden Vorwurf 
;; des Kommunismus nicht zurückgeschleudert hätte?

;; Zweierlei geht aus dieser Thatsache hervor.

;; Der Kommunismus wird bereits von allen europäischen Mächten 
;; als eine Macht anerkannt.

;; Es ist hohe Zeit daß die Kommunisten ihre Anschauungsweise, 
;; ihre Zwecke, 
;; ihre Tendenzen vor der ganzen Welt offen darlegen, 
;; und den Mährchen vom Gespenst des Kommunismus 
;; ein Manifest der Partei selbst entgegenstellen.")
  #+END_SRC 
** Doom macros
*** after!
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms))))
  #+END_SRC 
*** add-hook!
    #+BEGIN_SRC emacs-lisp
(eval-and-compile 
(defun doom-enlist (exp)
  "Return EXP wrapped in a list, or as-is if already a list."
  (if (listp exp) exp (list exp)))

(defun doom-unquote (exp)
  "Return EXP unquoted."
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)


(defun doom--resolve-hook-forms (hooks)
  (cl-loop with quoted-p = (eq (car-safe hooks) 'quote)
           for hook in (doom-enlist (doom-unquote hooks))
           if (eq (car-safe hook) 'quote)
            collect (cadr hook)
           else if quoted-p
            collect hook
           else collect (intern (format "%s-hook" (symbol-name hook)))))

(defvar doom--transient-counter 0)

(defmacro add-transient-hook! (hook &rest forms)
  "Attaches transient forms to a HOOK.
HOOK can be a quoted hook or a sharp-quoted function (which will be advised).
These forms will be evaluated once when that function/hook is first invoked,
then it detaches itself."
  (declare (indent 1))
  (let ((append (eq (car forms) :after))
        (fn (intern (format "doom-transient-hook-%s" (cl-incf doom--transient-counter)))))
    `(when ,hook
       (fset ',fn
             (lambda (&rest _)
               ,@forms
               (cond ((functionp ,hook) (advice-remove ,hook #',fn))
                     ((symbolp ,hook)   (remove-hook ,hook #',fn)))
               (unintern ',fn nil)))
       (cond ((functionp ,hook)
              (advice-add ,hook ,(if append :after :before) #',fn))
             ((symbolp ,hook)
              (add-hook ,hook #',fn ,append))))))

      (defmacro add-hook! (&rest args)
  "A convenience macro for `add-hook'. Takes, in order:
  1. Optional properties :local and/or :append, which will make the hook
     buffer-local or append to the list of hooks (respectively),
  2. The hooks: either an unquoted major mode, an unquoted list of major-modes,
     a quoted hook variable or a quoted list of hook variables. If unquoted, the
     hooks will be resolved by appending -hook to each symbol.
  3. A function, list of functions, or body forms to be wrapped in a lambda.
Examples:
    (add-hook! 'some-mode-hook 'enable-something)
    (add-hook! some-mode '(enable-something and-another))
    (add-hook! '(one-mode-hook second-mode-hook) 'enable-something)
    (add-hook! (one-mode second-mode) 'enable-something)
    (add-hook! :append (one-mode second-mode) 'enable-something)
    (add-hook! :local (one-mode second-mode) 'enable-something)
    (add-hook! (one-mode second-mode) (setq v 5) (setq a 2))
    (add-hook! :append :local (one-mode second-mode) (setq v 5) (setq a 2))
Body forms can access the hook's arguments through the let-bound variable
`args'."
  (declare (indent defun) (debug t))
  (let ((hook-fn 'add-hook)
        append-p local-p)
    (while (keywordp (car args))
      (pcase (pop args)
        (:append (setq append-p t))
        (:local  (setq local-p t))
        (:remove (setq hook-fn 'remove-hook))))
    (let ((hooks (doom--resolve-hook-forms (pop args)))
          (funcs
           (let ((val (car args)))
             (if (memq (car-safe val) '(quote function))
                 (if (cdr-safe (cadr val))
                     (cadr val)
                   (list (cadr val)))
               (list args))))
          forms)
      (dolist (fn funcs)
        (setq fn (if (symbolp fn)
                     `(function ,fn)
                   `(lambda (&rest _) ,@args)))
        (dolist (hook hooks)
          (push (if (eq hook-fn 'remove-hook)
                    `(remove-hook ',hook ,fn ,local-p)
                  `(add-hook ',hook ,fn ,append-p ,local-p))
                forms)))
      `(progn ,@(nreverse forms))))))
      #+END_SRC 
*** def-setting!
#+BEGIN_SRC emacs-lisp
(eval-and-compile
(defvar doom-settings nil)
  (defmacro def-setting! (keyword arglist &optional docstring &rest forms)
  "Define a setting. Like `defmacro', this should return a form to be executed
when called with `set!'. FORMS are not evaluated until `set!' calls it.
See `doom/describe-setting' for a list of available settings.
Do not use this for configuring Doom core."
  (declare (indent defun) (doc-string 3))
  (unless (keywordp keyword)
    (error "Not a valid property name: %s" keyword))
  (let ((fn (intern (format "doom--set%s" keyword))))
    `(progn
       (defun ,fn ,arglist
         ,docstring
         ,@forms)
       (cl-pushnew ',(cons keyword fn) doom-settings :test #'eq :key #'car)))))
  #+END_SRC 
*** set!
#+BEGIN_SRC emacs-lisp
(eval-and-compile 
(defvar doom-debug-mode (or (getenv "DEBUG") init-file-debug)
  "If non-nil, all doom functions will be verbose. Set DEBUG=1 in the command
line or use --debug-init to enable this.")

(defmacro set! (keyword &rest values)
  "Set an option defined by `def-setting!'. Skip if doesn't exist. See
`doom/describe-setting' for a list of available settings."
  (declare (indent defun))
  (unless values
    (error "Empty set! for %s" keyword))
  (let ((fn (cdr (assq keyword doom-settings))))
    (if fn
        (apply fn values)
      (when doom-debug-mode
        (message "No setting found for %s" keyword)
        nil)))))
  #+END_SRC 
** User info
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Carlos Alberto Rivera Carreño"
        user-mail-address "cantorlunae@gmail.com")
#+END_SRC 
** Tangling 
   This code, which I borrowed from another user, sets up tangling to
   byte-compile the /init.org/ file, and thus, make Emacs load faster. Also,
   when byte-compiling, Emacs displays whether there are any errors or
   warnings, which makes it easier to track bugs and else.
   #+BEGIN_SRC emacs-lisp
     (defun tangle-init ()
       "If the current buffer is 'init.org' the code-blocks are
     tangled, and the tangled file is compiled."
       (when (equal (buffer-file-name)
                    (expand-file-name (concat user-emacs-directory "init.org")))
         ;; Avoid running hooks when tangling.
         (let ((prog-mode-hook nil))
           (org-babel-tangle)
           (byte-compile-file (concat user-emacs-directory "init.el")))))
     (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC 
** Packages
   #+BEGIN_SRC emacs-lisp
     ;;     (require 'cl)
     ;;     (require 'package)

     ;; Initialize Emac's package manager
     (package-initialize)

     ;; Set up the package repositories 
     (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/"))
     (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
     ;;     (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))

     (setq package-check-signature nil)
   #+END_SRC
** Use-package
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (setq use-package-verbose t)
  ;;(setq use-package-always-ensure t)
  (require 'use-package)
  ;;  (eval-when-compile
  ;;  (require 'use-package))
  ;;(use-package diminish )
  (require 'bind-key)
#+END_SRC 
** Modeline
#+BEGIN_SRC emacs-lisp
  ;; Display time in modeline.
  (display-time-mode 1)
  (display-battery-mode 1)

  ;; (setq mode-line-format
  ;;           (list
  ;;            ;; value of `mode-name'
  ;;            "%m: "
  ;;            ;; value of current buffer name
  ;;            "buffer %b, "
  ;;            ;; value of current line number
  ;;            "line %l "
  ;;            "-- user: "
  ;;            ;; value of user
  ;;            (getenv "USER")))
#+END_SRC 
** Line numbers
#+BEGIN_SRC emacs-lisp
  ;; Use the following with emacs-version > 26 
     ;;(setq-default ;; display-line-numbers-type 'visual
    ;;               display-line-numbers-current-absolute t
    ;;               display-line-numbers-width 4
     ;;              display-line-numbers-widen nil)
  (when (version<= "26.0.50" emacs-version )
    (global-display-line-numbers-mode))

  #+END_SRC 
** Fancy Battery 
#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :init 
    (add-hook 'after-init-hook #'fancy-battery-mode))
  #+END_SRC 
** Workspace settings 
   #+BEGIN_SRC emacs-lisp
          (tool-bar-mode -1) 
          (menu-bar-mode -1)
          (scroll-bar-mode -1)
          ;;(menu-bar-showhide-fringe-menu-customize-disable)
          ;; begin maxmized
          (add-to-list 'default-frame-alist '(fullscreen . maximized))

          (setq mode-line-format nil
                inhibit-splash-screen t
                echo-keystrokes 0.1
                auto-revert-interval 1
                )

          (setq-default                    
           ;; Use spaces instead of tabs
           indent-tabs-mode nil              
           ;; Split verticly by default
           split-width-threshold 160         
           ;; Split verticly by default
           split-height-threshold nil        
           ;; disable bidirectional text for tiny performance boost
           bidi-display-reordering nil 
           ;; don't blink--too distracting
           blink-matching-paren nil    
           ;; hide cursors in other windows
           cursor-in-non-selected-windows nil  
           frame-inhibit-implied-resize t
           ;; avoid ugly problèmes with gît-gutter 
           fringes-outside-margins t
           ;; left-margin-width 3
           ;; right-margin-width 7
           left-fringe-width 3
           right-fringe-width 0
           ;; remove continuation arrow on right fringe
           fringe-indicator-alist (delq (assq 'continuation fringe-indicator-alist)
                                        fringe-indicator-alist)
           highlight-nonselected-windows nil
           image-animate-loop t
           indicate-buffer-boundaries nil
           indicate-empty-lines nil
           max-mini-window-height 0.3
           )

          ;; highlight matching delimiters
          (setq show-paren-delay 0.1
                show-paren-highlight-openparen t
                show-paren-when-point-inside-paren t)
          (show-paren-mode 1)

     ;; On graphical displays, you can use window dividers in order to separate
     ;; windows visually.
          (setq-default window-divider-default-places t
                        window-divider-default-bottom-width 0
                        window-divider-default-right-width 1)
          (add-hook 'emacs-startup-hook #'window-divider-mode)

          ;; (use-package fringe-helper :load-path "~/.emacs.d/sync0_git/fringe-helper.el/" 
          ;;   :commands (fringe-helper-define fringe-helper-convert))

          ;; make navigation easy
          ;; (setq frame-title-format "%b")

          ;;Workspace keybindgs
          (defun toggle-mode-line () 
            "toggles the modeline on and off"
            (interactive) 
            (setq mode-line-format
                  (if (equal mode-line-format nil)
                      (default-value 'mode-line-format)) )
            (redraw-display))

          (global-set-key [C-f11] 'toggle-mode-line)
          (global-set-key (kbd "<f8>") 'tool-bar-mode)
          (global-set-key (kbd "<f9>") 'menu-bar-mode)
#+END_SRC
** Mixed settings
#+BEGIN_SRC emacs-lisp
    ;; Bookmarks directory
    (setq bookmark-default-file (concat user-emacs-directory "bookmarks")
          bookmark-save-flag 1)

    ;; Autosave
    (setq auto-save-interval 100
             auto-save-timeout 60)

    ;; CUSTOM directory
    (setq custom-file (expand-file-name "custom_settings.el" user-emacs-directory))
    (load custom-file t)

    ;; Remove yes-no EMACS inconsistency
    (fset 'yes-or-no-p 'y-or-n-p)

    ;; Git gutter thingy
      (defvar doom-fringe-size '3 "Default fringe width.")
;; (defconst doom-fringe-size '3 "Default fringe width")
    ;; ;; ;; (setq-default fringes-outside-margins t)
       (fringe-mode doom-fringe-size)
(if (fboundp 'fringe-mode) (fringe-mode doom-fringe-size))
      ;;(push `(left-fringe  . ,doom-fringe-size) default-frame-alist)
      ;;(push `(right-fringe . ,doom-fringe-size) default-frame-alist)

      ;;(if (fboundp 'fringe-mode) (fringe-mode doom-fringe-size))
    ;;  (fringe-mode '(3 . 0))
  ;;    (if (fboundp 'fringe-mode) (fringe-mode '(3 . 0)))

  ;; margins fonction
  ;;(defun sync0-fringes ()
   ;;"Set margins in current buffer."
 ;;        (setq-default left-fringe-width 3)
;;         (setq-default right-fringe-width 0))

   ;; (add-hook 'text-mode-hook 'sync0-fringes)

     (defun doom|no-fringes-in-minibuffer ()
       "Disable fringes in the minibuffer window."
       (set-window-fringes (minibuffer-window) 0 0 nil))
     (add-hook! '(after-init-hook minibuffer-setup-hook)
       #'doom|no-fringes-in-minibuffer)

    ;; Force UTF-8 encoding

    ;; disable CJK coding/encoding (Chinese/Japanese/Korean characters)
    ;; (setq utf-translate-cjk-mode nil)
    (set-language-environment 'utf-8)
    ;; backwards compatibility as default-buffer-file-coding-system
    ;; is deprecated in 23.2.
    ;; (if (boundp buffer-file-coding-system)
    ;;    (setq buffer-file-coding-system 'utf-8)
    ;; (setq default-buffer-file-coding-system 'utf-8))

    ;; set the default encoding system
    (setq default-file-name-coding-system 'utf-8)
    (set-default-coding-systems 'utf-8)
    (setq locale-coding-system 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (when (display-graphic-p)

    ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
       (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC
** List of recent files
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    (setq recentf-max-saved-items 100
     recentf-max-menu-items 10)
    (recentf-mode +1)
  (define-key recentf-dialog-mode-map (kbd "j") 'next-line)
  (define-key recentf-dialog-mode-map (kbd "k") 'previous-line))
#+END_SRC
** 取 Margins to buffer
;; setting margins at start up
(setq left-margin-width 4)
;;(setq right-margin-width 26)

;; margins function
(defun my-toggle-margins ()
"Set margins in current buffer."
(interactive)
  (if (or (> left-margin-width 0) (> right-margin-width 0))
    (progn
      (setq left-margin-width 0)
      (setq right-margin-width 0)
      (set-window-buffer (selected-window) (current-buffer)))
    (setq left-margin-width 26)
    (setq right-margin-width 26)
    (set-window-buffer (selected-window) (current-buffer))))

;; set key binding
(global-set-key [C-f9] 'my-toggle-margins)
** Text settings
*** Set default faces
 #+BEGIN_SRC emacs-lisp
     ;; select default faces
     (set-face-attribute 'default nil :font "Fira Mono")
   ;; adjust font size according to screen resolution (when I use dual monitor setup)
     (if window-system
         (progn
           (if (> (x-display-pixel-width) 2000)
               ;; dual monitor font size
               (progn
                 ;; interline spacing
                 (setq line-spacing 0.14)
                 (set-face-attribute 'default nil :height 140) )
             (progn
               ;; interline spacing
               (setq line-spacing 0.12)
               ;; laptop font size
               (set-face-attribute 'default nil :height 120)))))

       (defun my-buffer-face-mode-fixed ()
         "Sets a fixed width (monospace) font in current buffer"
         (interactive)
         (if window-system
             (progn
               (if (> (x-display-pixel-width) 1500)
                   ;; dual monitor
                   (setq buffer-face-mode-face '(:family "Fira Mono" :height 140 :spacing monospace)) 
                 ;; laptop
                 (setq buffer-face-mode-face '(:family "Fira Mono" :height 120 :spacing monospace)))))
         (buffer-face-mode))

       ;; Variable-width faces 
       (defun my-buffer-face-mode-variable ()
         "Set font to a variable width (proportional) fonts in current buffer"
         (interactive)
         (if window-system
             (progn
               (if (> (x-display-pixel-width) 1500)
                   ;; external monitor
                   (setq buffer-face-mode-face '(:family "Linux Libertine" :height 170)) 
                 ;; laptop
                 (setq buffer-face-mode-face '(:family "Linux Libertine" :height 140)))))
         (buffer-face-mode))

       ;; Set default font faces for Info, ERC, and Org
       (add-hook 'erc-mode-hook 'my-buffer-face-mode-variable)
       (add-hook 'Info-mode-hook 'my-buffer-face-mode-variable)
       (add-hook 'text-mode-hook 'my-buffer-face-mode-variable)




       ;;   (defun fontify-frame (frame)
       ;; (interactive)
       ;; (if window-system
       ;; (progn 
       ;; (if (> (x-display-pixel-width) 2000) 
       ;; (text-scale-set 0) 
       ;;              (text-scale-set 0.8)))))

       ;; ;; Fontify current frame
       ;; (fontify-frame nil)

       ;; ;; Fontify any future frames
       ;; (push 'fontify-frame after-make-frame-functions)

       ;; Allow narrowing
       (put 'narrow-to-region 'disabled nil)

       ;; Sentences end with single espace
       (setq sentence-end-double-space nil)

       ;; Word wrap
       (setq org-startup-truncated t)
  #+END_SRC
*** Add blank lines
#+BEGIN_SRC emacs-lisp
  (defun sync0-insert-line-below ()
  "Insert an empty line below the current line."
  (interactive)
  (save-excursion
    (end-of-line)
    (open-line 1)))

(defun sync0-insert-line-above ()
  "Insert an empty line above the current line."
  (interactive)
  (save-excursion
    (end-of-line 0)
    (open-line 1)))
  #+END_SRC 
*** Auto-fill settings
 #+BEGIN_SRC emacs-lisp
      (setq-default fill-column 75)
      (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
      (add-hook 'LaTeX-mode-hook 'turn-on-visual-line-mode)
      ;; (add-hook 'text-mode-hook 'turn-off-auto-fill)
      (add-hook 'org-mode-hook 'turn-on-auto-fill)
      ;; (add-hook 'LaTeX-mode-hook 'turn-on-auto-fill)
      ;; respect de la typographie française par fill
      ;;(setq fill-nobreak-predicate '(fill-french-nobreak-p))

      (defun sync0-is-this-a-csquote ()
        "Find wheter current line begins with a LaTeX csquote"
        (or 
         (looking-back "blockquote.+" (line-beginning-position))
         (looking-back "blockcquote.+" (line-beginning-position))
         (looking-back "foreignblockquote.+" (line-beginning-position))
         (looking-back "foreignblockcquote.+" (line-beginning-position))
         (looking-back "annotation{.+" (line-beginning-position))
         ;; (looking-back "replaced{.+" (line-beginning-position))
         ;; (looking-back "added{.+" (line-beginning-position))
         ;; (looking-back "deleted{.+" (line-beginning-position))
         (looking-back "textbf{.+" (line-beginning-position))
         (looking-back "textit{.+" (line-beginning-position))
         ))

      (add-hook 'fill-nobreak-predicate #'sync0-is-this-a-csquote)

      ;; (looking-at ".*}"))

   (defun sync0-fill-nobreak-predicate ()
     (save-match-data                 
       (or (looking-at "[ \t]*[])}»!?;:]")
           (looking-at "[ \t]*\\.\\.\\.")
           (save-excursion
             (skip-chars-backward " \t")
             (backward-char 1)
             (looking-at "[([{«]")))))

      (add-hook 'fill-nobreak-predicate #'sync0-fill-nobreak-predicate)

      ;; (defun sync0-foreign-language-nobreak-p ()
      ;;   (or    (looking-at "[[[:space:]]\|[[:print:]]].*}")
      ;;          (save-excursion 
      ;;            (skip-chars-backward " \t")
      ;;            (unless (bolp)
      ;;              (backward-char 1)
      ;;              (looking-at ".*\\text")))))

      ;; (add-hook 'fill-nobreak-predicate #'sync0-foreign-language-nobreak-p)


      ;; (defun sync0-foreign-language-nobreak-p ()
      ;;   "Return nil if French style allows breaking the line at point.
      ;; This is used in `fill-nobreak-predicate' to prevent breaking lines just
      ;; after an opening paren or just before a closing paren or a punctuation
      ;; mark such as `?' or `:'.  It is common in French writing to put a space
      ;; at such places, which would normally allow breaking the line at those
      ;; places."
      ;;   (or (looking-at "[ \t]*}")
      ;;       (save-excursion
      ;;         (skip-chars-backward " \t")
      ;;         (unless (bolp)
      ;;           (backward-char 1)
      ;;           (or (looking-at "{")
      ;;               ;; Don't cut right after a single-letter word.
      ;;               ;; and, memq: tests to see whether object is a member of list. ?\t: tab character. ?\s: espace character
      ;;               (and (memq (preceding-char) '(?\t ?\s))
      ;;                    (eq (char-syntax (following-char)) ?w)))))))

      ;;    (add-hook 'fill-nobreak-predicate #'sync0-foreign-language-nobreak-p)

      ;; (save-excursion 
      ;;  (search-forward "}"
      ;;    (line-end-position)
      ;;     nil
      ;;      1)
      ;; (defun sync0-nobreak-p ()
      ;;   (and (looking-at ".+}")
      ;;        (looking-back "\\text.+" (line-beginning-position))))

      ;; (add-hook 'fill-nobreak-predicate #'sync0-nobreak-p)


      ;; (defun sync0-nobreak-p ()
      ;;   (and (looking-at ".+}")
      ;;        (looking-back "\\text.+" (line-beginning-position))))

      ;; (add-hook 'fill-nobreak-predicate #'sync0-nobreak-p)


      ;;(setq fill-nobreak-predicate '(sync0-is-this-a-csquote))
      ;;      (add-hook 'fill-nobreak-predicate #'sync0-is-this-a-csquote)
      ;;(add-to-list 'fill-nobreak-predicate
      ;;     'sync0-is-this-a-csquote)
  #+END_SRC
*** Autofill improvement
  (defun sync0-is-this-a-csquote ()
    "Find wheter current line begins with a LaTeX csquote"
    (save-excursion
      (beginning-of-line)
      (or (looking-at ".blockquote.+") 
          (looking-at "[[:space:]]+.blockquote.+") 
          (looking-at ".foreignblockquote.+")
          (looking-at "[[:space:]]+.foreignblockquote.+")
          )))

(defun sync0-is-this-a-csquote ()
  "Find wheter current line begins with a LaTeX csquote"
  (save-excursion
    (beginning-of-line)
    (or (looking-at ".blockquote.+") (looking-at ".foreignblockquote.+"))))

(add-to-list 'fill-nobreak-predicate
     'sync0-is-this-a-csquote)



(defun odd-number-of-single-quotes-this-paragraph-so-far ()
  (oddp (how-many "'" (save-excursion (backward-paragraph) (point)) (point))))
(defun odd-number-of-double-quotes-this-paragraph-so-far ()
  (oddp (how-many "\"" (save-excursion (backward-paragraph) (point)) (point))))

(add-to-list 'fill-nobreak-predicate
     'odd-number-of-single-quotes-this-paragraph-so-far) (add-to-list
     'fill-nobreak-predicate
     'odd-number-of-double-quotes-this-paragraph-so-far)

- firt make a defun
- then use this model

(defun sync0-is-this-a-csquote ()
  "Find wheter current line begins with a LaTeX csquote"
  (save-excursion
    (beginning-of-line)
    (or (looking-at ".blockquote.+") (looking-at ".foreignblockquote.+"))))

(add-to-list 'fill-nobreak-predicate
     'sync0-is-this-a-csquote)

(buffer-substring 1 10)

(defun creole-mode/fill-break-p ()
  "Fill computation for Creole.
Basically just does not fill within links."
  (memq 'link (text-properties-at (point))))

(defun sync0-unfill-csquotes ()
  "Fill computation for LaTeX's csquotes and Emacs' orgmode.
Basically just does not fill strings begining with ."
  ((memq ' (thing-at-point (line)))

(defun current-line-empty-p ()
  (save-excursion
    (beginning-of-line)
    (or (looking-at "^\\blockquote") (looking-at "^\\foreignblockquote")))
*** Replace smart quotes with straight quotes 
Replace smart quotes with straight quotes so that spell check can recognize
words with contractions like “don’t” and “can’t.” For when I paste text in
that I’ve copied from the web.
#+BEGIN_SRC emacs-lisp
(setq smart-quote-regexp-replacements
'(
("\\(\\w\\)- " . "\\1")
("\\(\\w\\)\\(  [-—] \\|—\\)" . "\\1---")

))

(defun replace-smart-quotes-regexp (beg end)
  "Replace 'smart quotes' in buffer or region with ascii quotes."
  (interactive "r")
  (mapcar
   (lambda (r)
     (save-excursion
       (replace-regexp (car r) (cdr r) nil beg (min end (point-max)))))
   smart-quote-regexp-replacements)
  )

(defun replace-smart-quotes (beg end)
  "Replace 'smart quotes' in buffer or region with ascii quotes."
  (interactive "r")
;;(while (search-forward-regexp "- " nil to)
;; (replace-match "") nil t)
;; add alpha. And replace the alpha.

  (replace-smart-quotes-regexp beg end)
  (format-replace-strings '(
                            ("\x201C" . "``")
                            ("“" . "``")
                            ("\x201D" . "''")
                            ("”" . "''")
                            ("\x2018" . "`")
                            ("\x2019" . "'")
                            ("’" . "'")
;;("''" . "\"")
;;("​" . "")
;;("…" . "...")
("…" . "\\ldots")
("..." . "\\ldots")
;;("• " . "- ")
;;(" " . "")
("  " . " ")

;("ó" . "-")
;("á" . "-")
;("Õ" . "'")
;("Õ" . "'")
;("Ò" . "\"")
;("Ó" . "\"")

;("―" . "\"")
;("‖" . "\"")

;; ("- " . "") ; also remove stray spac- es
;; ("­ " . "") ; also remove stray spac- es
)
                       nil   beg (min end (point-max)))

)
#+END_SRC 
** Abbrev Mode
#+BEGIN_SRC emacs-lisp
  ;; avoid expansion character insertion
  (defun dont-insert-expansion-char ()  t)    ;; this is the "hook" function
  (put 'dont-insert-expansion-char 'no-self-insert t)   ;; the hook should have a "no-self-insert"-property set 

  ;; tell emacs where to read abbrev
  (setq abbrev-file-name             
        "~/.emacs.d/abbrev_defs")    

  ;; save abbrevs when files are saved
  (setq save-abbrevs t)              

  ;; avoid errors when reading abbrev_defs
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file))

  ;; automatically turn on abbrev-mode for the following modes
  (dolist (hook '(
                  emacs-lisp-mode-hook
                  text-mode-hook))
    (add-hook hook (lambda () (abbrev-mode 1))))

  ;; try emacs to accept ' as a word constituent. 
  (setq dabbrev-abbrev-char-regexp  "\\sw")
#+END_SRC
** Elisp evaluation
#+BEGIN_SRC emacs-lisp
  ;; (use-package lisp-mode
  ;; :defer t
  ;;   :init
  ;; (use-package eldoc
  ;;       :init
  ;;       (progn
  ;;         (add-hook 'emacs-lisp-mode-hook #'eldoc-mode)
  ;;         (add-hook 'lisp-interaction-mode-hook #'eldoc-mode)
  ;;         (add-hook 'ielm-mode-hook #'eldoc-mode))))

  ;; Have org-mode indent elips sections by default
  (setq org-src-tab-acts-natively t) 
#+END_SRC 
** LaTeX 
#+BEGIN_SRC emacs-lisp
  ;; (defun sync0-latex-compile-after-save ()
  ;; ""
  ;;     (when (bound-and-true-p LaTeX-mode) 
  ;; (sync0-latex-compile)
  ;; )

  (defun sync0-latex-fast-compile ()
    "Fast compile current file"
        (TeX-command "LaTeX" 'TeX-master-file))

  (defun sync0-after-save-actions ()
    "Used in `after-save-hook'."
    (when (equal this-command 'save-buffer)
      (when (equal major-mode 'latex-mode) 
        (sync0-latex-fast-compile)))
    )

  (add-hook 'after-save-hook 'sync0-after-save-actions)
  #+END_SRC 
** LaTeX changes package
(defvar sync0-tex-changes-id "sync0")

(defun sync0-tex-changes-add ()
"Inserts an \added command to a LaTeX document using the 'changes' package"
  (interactive)
    (insert (concat "\\added[id=" sync0-tex-changes-id  "]{}"))
    (goto-char (- (point) 2))
(evil-insert-state)
)

(defun sync0-tex-changes-delete ()
  "Inserts an \delete command to a LaTeX document using the 'changes' package"
  (interactive)
  (if (use-region-p)
      (save-excursion
        (let ((low (region-beginning))
              (high (region-end))
               (command (concat "\\deleted[id=" sync0-tex-changes-id  "]{")))
        (goto-char high)
        (insert "}")
        (goto-char low)
        (insert command)))
    (message "This command can only act on an active region")))


(defun sync0-tex-changes-replace ()
  "Inserts an \replace command to a LaTeX document using the     'changes' package"
  (interactive)
  (if (use-region-p)
      (let ((low (region-beginning))
            (high (region-end))
            (command (concat "\\replaced[id=" sync0-tex-changes-id  "]{}{")))
        (goto-char high)
        (insert "}")
        (goto-char low)
        (insert command)
        (goto-char (- (point) 2))
(evil-insert-state)
)
    (message "This command can only act on an active region")))
** LaTeX changes package
#+BEGIN_SRC emacs-lisp
  ;; (defvar sync0-tex-changes-id "sync0")

  (defun sync0-tex-changes-add ()
    "Inserts an \added command to a LaTeX document using the 'changes' package"
    (interactive)
    (insert "\\added{}")
    (goto-char (- (point) 2))
    (evil-insert-state)
    )

  (defun sync0-tex-changes-delete ()
    "Inserts an \delete command to a LaTeX document using the 'changes' package"
    (interactive)
    (if (use-region-p)
        (save-excursion
          (let ((low (region-beginning))
                (high (region-end))
                (command "\\deleted{"))
            (goto-char high)
            (insert "}")
            (goto-char low)
            (insert command)))
      (message "This command can only act on an active region")))

  (defun sync0-tex-changes-replace ()
    "Inserts an \replace command to a LaTeX document using the 'changes' package"
    (interactive)
    (if (use-region-p)
        (let ((low (region-beginning))
              (high (region-end))
              (command "\\replaced{}{"))
          (goto-char high)
          (insert "}")
          (goto-char low)
          (insert command)
          (goto-char (- (point) 2))
          (evil-insert-state))
      (message "This command can only act on an active region")))
  #+END_SRC 
* Packages 
** Highlight indentation
#+BEGIN_SRC emacs-lisp
  ;; (use-package highlight-indentation
  ;;   :commands (highlight-indentation-mode highlight-indentation-current-column-mode)
  ;;   :config
  ;;   (defun doom|inject-trailing-whitespace (&optional start end)
  ;;     "The opposite of `delete-trailing-whitespace'. Injects whitespace into
  ;; buffer so that `highlight-indentation-mode' will display uninterrupted indent
  ;; markers. This whitespace is stripped out on save, as not to affect the resulting
  ;; file."
  ;;     (interactive (progn (barf-if-buffer-read-only)
  ;;                         (if (use-region-p)
  ;;                             (list (region-beginning) (region-end))
  ;;                           (list nil nil))))
  ;;     (unless indent-tabs-mode
  ;;       (save-match-data
  ;;         (save-excursion
  ;;           (let ((end-marker (copy-marker (or end (point-max))))
  ;;                 (start (or start (point-min))))
  ;;             (goto-char start)
  ;;             (while (and (re-search-forward "^$" end-marker t) (< (point) end-marker))
  ;;               (let (line-start line-end next-start next-end)
  ;;                 (save-excursion
  ;;                   ;; Check previous line indent
  ;;                   (forward-line -1)
  ;;                   (setq line-start (point)
  ;;                         line-end (save-excursion (back-to-indentation) (point)))
  ;;                   ;; Check next line indent
  ;;                   (forward-line 2)
  ;;                   (setq next-start (point)
  ;;                         next-end (save-excursion (back-to-indentation) (point)))
  ;;                   ;; Back to origin
  ;;                   (forward-line -1)
  ;;                   ;; Adjust indent
  ;;                   (let* ((line-indent (- line-end line-start))
  ;;                          (next-indent (- next-end next-start))
  ;;                          (indent (min line-indent next-indent)))
  ;;                     (insert (make-string (if (zerop indent) 0 (1+ indent)) ? )))))
  ;;               (forward-line 1)))))
  ;;       (set-buffer-modified-p nil))
  ;;   nil)

    ;; (defun highlight-indentation-handle-whitespace ()
    ;;   (if (or highlight-indentation-mode highlight-indentation-current-column-mode)
    ;;       (progn
    ;;         (doom|inject-trailing-whitespace)
    ;;         (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)
    ;;         (add-hook 'after-save-hook #'doom|inject-trailing-whitespace nil t))
    ;;     (remove-hook 'before-save-hook #'delete-trailing-whitespace t)
    ;;     (remove-hook 'after-save-hook #'doom|inject-trailing-whitespace t)
    ;;     (delete-trailing-whitespace)))
    ;; (add-hook 'highlight-indentation-mode-hook 'highlight-indentation-handle-whitespace)
    ;; (add-hook 'highlight-indentation-current-column-mode-hook 'highlight-indentation-handle-whitespace)

     (use-package highlight-indentation
     :commands (highlight-indentation-mode highlight-indentation-current-column-mode))

  ;; ;; For modes with sub-par number fontification
  ;; (use-package highlight-numbers :commands highlight-numbers-mode)

  ;; languages like Lisp.
  (use-package rainbow-delimiters
    :hook (lisp-mode . rainbow-delimiters-mode)
    :config (setq rainbow-delimiters-max-face-count 3))
  #+END_SRC 
** All the icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons :after ivy
:config
;; ivy setup
(progn
(all-the-icons-ivy-setup)
;; improve performance 
(setq inhibit-compacting-font-caches t)))
#+END_SRC 
** Doom theme
#+BEGIN_SRC emacs-lisp
      (use-package doom-themes  
    :init
    (progn
        ;;(load-theme 'doom-one-vibrant t)
        ;;(load-theme 'doom-molokai t)
        ;;(load-theme 'doom-peacock t)
        ;;(load-theme 'doom-tomorrow-night t)
      (load-theme 'doom-spacegrey t)    
        ;;(load-theme 'doom-one-light t)
        ;;(load-theme 'doom-tomorrow-day t)
        ;;(load-theme 'doom-one t)
        ;(load-theme 'doom-nova t)
       ;; (load-theme 'doom-nord t)
        (load-theme 'doom-solarized-light t))
    ;;    (load-theme 'doom-solarized-light t)
        :config
        ;; (setq spaceline-all-the-icons-separator-type 'none)
        (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
              doom-themes-enable-italic t) ; if nil, italics is universally disabled
        ;; Enable flashing mode-line on errors
        (doom-themes-visual-bell-config)
        ;; Enable custom neotree thème
    ;;    (doom-themes-neotree-config)  ; all-the-icons fonts must be installed!
        ;; Corrects (and improves) org-mode's native fontification.
        (doom-themes-org-config))

      ;; Cycley between thèmes
     (use-package cycle-themes :load-path "~/.emacs.d/sync0_git/cycle-themes.el/" 
     :after doom-themes
       :init (setq cycle-themes-theme-list
           ;;  '(doom-spacegrey doom-nova doom-nord doom-solarized-light))
           ;;  '(doom-spacegrey doom-nova doom-solarized-light))
             '(doom-spacegrey doom-solarized-light))
       :config (cycle-themes-mode))
#+END_SRC 
** Spellchecking
 #+BEGIN_SRC emacs-lisp
   ;; Ispell - spell checking
   ;; basic setup

(setq ispell-hunspell-dict-paths-alist
      '(("en_US-large" "/usr/share/hunspell/en_US-large.aff")
        ("fr_FR" "/usr/share/hunspell/fr_FR.aff")
        ("de_DE" "/usr/share/hunspell/de_DE.aff")
        ("it_IT" "/usr/share/hunspell/it_IT.aff")
        ("fr_FR" "/usr/share/hunspell/fr_FR.aff")
        ("es_ANY" "/usr/share/hunspell/es_ANY.aff")))

    (cond
      ;; try hunspell at first
      ;; if hunspell does NOT exist, use aspell
     ((executable-find "hunspell")
      (setq ispell-program-name "hunspell")
      ;; (setq ispell-local-dictionary "fr_FR")
      ;;(setq ispell-local-dictionary "en_US")
      (setq ispell-local-dictionary-alist '(  
        (nil "[[:alpha:]]" "[^[:alpha:]]" "['’-]" nil ("-d" "en_US-large" ) nil utf-8)
        ("en_US-large" "[[:alpha:]]" "[^[:alpha:]]" "['’-]" t ("-d" "en_US-large" ) nil utf-8)
        ("de_DE" "[[:alpha:]ÄÖÜéäöüß]" "[^[:alpha:]ÄÖÜéäöüß]" "['’-]" t ("-d" "de_DE") nil utf-8)
        ("es_ANY" "[[:alpha:]ÁÉÍÓÚÄËÏÖÜÑáéíóúäëïöüñ]" "[^[:alpha:]ÁÉÍÓÚÄËÏÖÜÑáéíóúäëïöüñ]" "['’-]" t ("-d" "es_ANY") nil utf-8)
        ("it_IT" "[[:alpha:]AEÉIOUàèéìòù]" "[^[:alpha:]AEÉIOUàèéìòù]" "['’-]" t ("-d" "it_IT") "~tex" nil utf-8)
        ("fr_FR" "[[:alpha:]ÀÂÇÈÉÊËÎÏÔÙÛÜàâçèéêëîïôùûü]" "[^[:alpha:]ÀÂÇÈÉÊËÎÏÔÙÛÜàâçèéêëîïôùûü]" "[-'`]" t ("-d" "fr_FR")  nil utf-8))))

     ((executable-find "aspell")
      (setq ispell-program-name "aspell")
      ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
      (setq ispell-extra-args '("--sug-mode=ultra"))))
      ;;(setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))))
      ;;(setq ispell-extra-args '("--sug-mode=ultra" "--lang=fr_FR"))))

    ;; check next highlighted word custom function
    (defun flyspell-check-next-highlighted-word ()
      "Custom function to spell check next highlighted word"
      (interactive)
      (flyspell-goto-next-error)
      (ispell-word)
      )

    ;; keybindings
    ;;(global-set-key (kbd "<f7>") 'ispell-word)
   ;; (global-set-key (kbd "C-S-<f7>") 'flyspell-mode)
    ;;(global-set-key (kbd "C-M-<f7>") 'flyspell-buffer)
    ;;(global-set-key (kbd "C-<f7>") 'flyspell-check-previous-highlighted-word)
    ;;(global-set-key (kbd "M-<f7>") 'flyspell-check-next-highlighted-word)

   ;; ignore tex commands
    (add-hook 'org-mode-hook (lambda () (setq ispell-parser 'tex)))
    (defun flyspell-ignore-tex ()
      (interactive)
      (set (make-variable-buffer-local 'ispell-parser) 'tex))
    (add-hook 'org-mode-hook 'flyspell-ignore-tex)

   ;; ignore sections of files for spellcheck
    (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_EXAMPLE" . "#\\+END_EXEMPLE"))
    (add-to-list 'ispell-skip-region-alist '("\\begin{equation}" . "\\end{equation}"))
    (add-to-list 'ispell-skip-region-alist '("\\begin{equation\*}" . "\\end{equation\*}"))
    (add-to-list 'ispell-skip-region-alist '("\\begin{align}" . "\\end{align}"))
    (add-to-list 'ispell-skip-region-alist '("\\begin{align\*}" . "\\end{align\*}"))
    ;; (add-to-list 'ispell-skip-region-alist '("\*Einstellungen+"))
    (add-to-list 'ispell-skip-region-alist '("\*Settings .+" . "\*\*Etc"))
   ;; (add-to-list 'ispell-skip-region-alist '("^\\*\sEinstellungen" . "^\\*\\*\sEnde"))

   ;; Flyspell
    ;;(setq-default flyspell-mode t)
    ;; better performance
    (setq flyspell-issue-message-flag nil)

   ;; Flyspell lazy
   (use-package flyspell-lazy :after flyspell :load-path "~/.emacs.d/sync0_git/flyspell-lazy"
   :config
    (flyspell-lazy-mode 1))

    (flyspell-mode 1)      ; or (flyspell-prog-mode)
 #+END_SRC 
** Tex
#+BEGIN_SRC emacs-lisp
(use-package tex
:defer t
:ensure auctex
:config
(setq preview-gs-command "/usr/local/bin/gs")
(setq TeX-PDF-mode t))
#+END_SRC
** No Break Predicate
#+BEGIN_SRC emacs-lisp
(use-package nobreak-fade :load-path "~/.emacs.d/sync0/nobreak-fade.el" 
:after tex
;; :command nobreak-fade
:config
     (autoload 'nobreak-fade-single-letter-p "nobreak-fade")
     (add-hook 'fill-nobreak-predicate 'nobreak-fade-single-letter-p)
;; (add-hook 'tex-mode-hook 'nobreak-fade)
)
#+END_SRC
** EVIL mode 
   #+BEGIN_SRC emacs-lisp
     ;; initializing
     (use-package evil  :after org
       :bind (
              ;; ESC quits almost anything
              :map evil-normal-state-map
                   ;;     ("ESC" . keyboard-quit)
                   ;; quickly switch buffers
                   ("C-j" . next-buffer)
                   ("C-k" . previous-buffer)
                   ("C-S-h" . evil-window-left)
                   ("C-S-j" . evil-window-down)
                   ("C-S-k" . evil-window-up)
                   ("C-S-l" . evil-window-right))
       ;;    :map evil-visual-state-map
       ;;   ("ESC" . keyboard-quit))
       ;; :map minibuffer-local-map
       ;;("ESC" . minibuffer-keyboard-quit)
       ;; :map minibuffer-local-ns-map
       ;;("ESC" . minibuffer-keyboard-quit)
       ;;:map minibuffer-local-completion-map
       ;; ("ESC" . minibuffer-keyboard-quit)
       ;;:map minibuffer-local-must-match-map
       ;; ("ESC" . minibuffer-keyboard-quit)
       ;;:map minibuffer-local-isearch-map
       ;;("ESC" . minibuffer-keyboard-quit))
       :init
       (evil-mode 1)
       :config


       ;;(add-hook 'org-mode-hook (lambda () (evil-mode 1)))
       ;;(add-hook 'after-init-hook '#evil-mode) 
       (add-to-list 'evil-emacs-state-modes 'cfw:details-mode)

       ;; input methods 
       ;; set default input method
       ;; (setq default-input-method "TeX")
       ;; no input method for evil normal state
       (add-hook 'evil-normal-state-entry-hook
                 (lambda () (set-input-method 'nil)))
       ;; Spanish

       ;; spanish-postfix for evil insert mode
       ;;(add-hook 'evil-insert-state-entry-hook
       ;; (lambda () (set-input-method "spanish-postfix")))

       ;; spanish-postfix for evil insert mode
       ;;(add-hook 'evil-insert-state-entry-hook
       ;; (lambda () (set-input-method "spanish-postfix")))
       ;; Latin

       ;; latin-1-postfix for evil replace mode
       ;;(add-hook 'evil-replace-state-entry-hook
       ;; (lambda () (set-input-method "latin-1-postfix")))

       ;; latin-1-postfix for evil replace mode
       ;;(add-hook 'evil-replace-state-entry-hook
       ;; (lambda () (set-input-method "latin-1-postfix")))

       ;; French 

       ;; french-postfix for evil insert mode 
       ;; (add-hook 'evil-insert-state-entry-hook 
       ;;           (lambda () (set-input-method "french-postfix")))

       ;; french-postfix for evil replace mode
       ;; (add-hook 'evil-replace-state-entry-hook
       ;;           (lambda () (set-input-method "french-postfix")))
       ;; German 

       ;; german-postfix for evil insert mode
       ;;(add-hook 'evil-insert-state-entry-hook
       ;;(lambda () (set-input-method "german-postfix")))

       ;; german-postfix for evil replace mode
       ;;(add-hook 'evil-replace-state-entry-hook
       ;;(lambda () (set-input-method "german-postfix")))

       ;; EVIL org
       ;; setup functions
       (defun clever-insert-item ()
         "Clever insertion of org item."
         (if (not (org-in-item-p))
             (insert "\n")
           (org-insert-item)))

       (defun evil-org-eol-call (fun)
         "Go to end of line and call provided function.
                 FUN function callback"
         (end-of-line)
         (funcall fun)
         (evil-append nil))

       ;; insert whitespace
       (defun sync0-insert-whitespace ()
         " Add a whitespace"
         (interactive)
         (insert " ")
         )
       ;; key bindings
       ;; redefinition evils visual mode map
       (evil-define-key 'normal org-mode-map
         ;; "<" 'outline-previous-visible-heading
         ">"   'org-forward-heading-same-level
         "<"  'org-backward-heading-same-level
         ;; ">" 'outline-next-visible-heading
         "H" 'org-metaleft
         "L" 'org-metaright
         "K" 'org-metaup
         "J" 'org-metadown
         ;; "K" 'outline-previous-visible-heading
         ;;"J" 'outline-next-visible-heading
         ;; "H" (if (fboundp 'org-backward-same-level)
         ;;   'org-backward-same-level
         ;;'org-backward-heading-same-level)
         ;;  "L" (if (fboundp 'org-forward-same-level) ;to be backward compatible with older org version
         ;;   'org-forward-same-level
         ;;'org-forward-heading-same-level)
         ;;  "<" 'org-metaleft
         ;; ">" 'org-metaright
         "k" 'previous-line
         "j" 'next-line
         ;;  "m" 'set-mark-command
         "q" 'fill-paragraph
         "Q" 'sync0-insert-line-below
         (kbd "SPC") 'sync0-insert-whitespace
         "o" '(lambda () (interactive) (evil-org-eol-call 'clever-insert-item))
         "O" '(lambda () (interactive) (evil-org-eol-call 'org-insert-heading))
         "$" 'org-end-of-line
         "^" 'org-beginning-of-line
         "[" 'backward-sentence
         "]" 'forward-sentence
         "{" 'org-backward-paragraph
         "}" 'org-forward-paragraph
         "-" 'org-cycle-list-bullet
         (kbd "<tab>") 'org-cycle)

       (evil-define-key 'normal LaTeX-mode-map
         "k" 'previous-line
         "j" 'next-line
         ;;  "m" 'set-mark-command
         "q" 'fill-paragraph
         "Q" 'sync0-insert-line-below
         (kbd "SPC") 'sync0-insert-whitespace
         "[" 'backward-sentence
         "]" 'forward-sentence)

       (evil-define-key 'visual LaTeX-mode-map
         "q" 'highlight-changes-remove-highlight
         "ma" 'sync0-tex-changes-add
         "md" 'sync0-tex-changes-delete
         "mr" 'sync0-tex-changes-replace)

       (evil-define-key 'visual org-mode-map
         "q" 'highlight-changes-remove-highlight
         "ma" 'sync0-tex-changes-add
         "md" 'sync0-tex-changes-delete
         "mr" 'sync0-tex-changes-replace
         "e" 'org-emphasize)

       (setq ;; evil-mode-line-format nil
             ;; turn off auto-indent 
             evil-auto-indent nil
             ;; Change color of evil cursor
             evil-insert-state-cursor '(bar "#dc322f")
             evil-normal-state-cursor '(box "#268bd2")
             evil-visual-state-cursor '(box "#d33682"))
       ;; Improve EVIL behavior with visual lines
       ;; Make movement keys work like they should
       (define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
       (define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
       (define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
       (define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)


       (defvar +evil-esc-hook '(t)
         "A hook run after ESC is pressed in normal mode (invoked by
          `evil-force-normal-state'). If any hook returns non-nil, all hooks after it are
          ignored.")

       (defun +evil*attach-escape-hook ()
         "Run the `+evil-esc-hook'."
         (cond ((minibuffer-window-active-p (minibuffer-window))
                ;; quit the minibuffer if open.
                (abort-recursive-edit))
               ((evil-ex-hl-active-p 'evil-ex-search)
                ;; disable ex search buffer highlights.
                (evil-ex-nohighlight))
               (t
                ;; Run all escape hooks. If any returns non-nil, then stop there.
                (run-hook-with-args-until-success '+evil-esc-hook))))
       (advice-add #'evil-force-normal-state :after #'+evil*attach-escape-hook)

       ;; Make horizontal movement cross lines                                    
       (setq-default evil-cross-lines t))
   #+END_SRC 
*** evil-snipe
#+BEGIN_SRC emacs-lisp
  ;; (use-package evil-snipe :after evil
  ;;   :commands (evil-snipe-mode evil-snipe-override-mode
  ;;              evil-snipe-local-mode evil-snipe-override-local-mode)
  ;;   :init
  ;;   (setq evil-snipe-smart-case t
  ;;         evil-snipe-scope 'visible
  ;;         ;;evil-snipe-scope 'line
  ;;         evil-snipe-repeat-scope 'whole-line
  ;;         evil-snipe-char-fold t
  ;;        ;; evil-snipe-disabled-modes 'magit-mode
  ;;         evil-snipe-aliases '((?\[ "[[{(]")
  ;;                              (?\] "[]})]")
  ;;                              (?\; "[;:]")))
  ;;   (add-hook 'after-init-hook 'evil-snipe-mode))
   ;;(add-hook 'magit-mode-hook 'turn-off-evil-snipe-override-mode)
   ;;(add-hook 'after-init-hook 'evil-snipe-override-mode))
  #+END_SRC 
*** evil-escape
#+BEGIN_SRC emacs-lisp
(use-package evil-escape :after evil
  :commands evil-escape-mode
  :init
  (setq evil-escape-excluded-states '(normal visual multiedit emacs motion)
        ;; evil-escape-excluded-major-modes '(neotree-mode)
        evil-escape-key-sequence "fd"
evil-escape-unordered-key-sequence t
        evil-escape-delay 0.25)
  (add-hook 'after-init-hook #'evil-escape-mode)
  :config
  ;; no `evil-escape' in minibuffer
  (push #'minibufferp evil-escape-inhibit-functions)
  (define-key evil-insert-state-map  (kbd "C-g") #'evil-escape)
 (define-key evil-replace-state-map (kbd "C-g") #'evil-escape)
  (define-key evil-visual-state-map  (kbd "C-g") #'evil-escape)
  (define-key evil-operator-state-map (kbd "C-g") #'evil-escape))
  #+END_SRC 
*** evil-multiedit
#+BEGIN_SRC emacs-lisp
           (use-package evil-multiedit :after evil
    ;; :commands (evil-multiedit-match-all
    ;;            evil-multiedit-match-and-next
    ;;            evil-multiedit-match-and-prev
    ;;            evil-multiedit-match-symbol-and-next
    ;;            evil-multiedit-match-symbol-and-prev
    ;;            evil-multiedit-toggle-or-restrict-region
    ;;            evil-multiedit-next
    ;;            evil-multiedit-prev
    ;;            evil-multiedit-abort
    ;;            evil-multiedit-ex-match)
  :config
  ;; Highlights all matches of the selection in the buffer.
  (define-key evil-visual-state-map "R" 'evil-multiedit-match-all)

  ;; Match the word under cursor (i.e. make it an edit region). Consecutive presses will
  ;; incrementally add the next unmatched match.
  (define-key evil-normal-state-map (kbd "M-d") 'evil-multiedit-match-and-next)
  ;; Match selected region.
  (define-key evil-visual-state-map (kbd "M-d") 'evil-multiedit-and-next)
  ;; Insert marker at point
  (define-key evil-insert-state-map (kbd "M-d") 'evil-multiedit-toggle-marker-here)

  ;; Same as M-d but in reverse.
  (define-key evil-normal-state-map (kbd "M-D") 'evil-multiedit-match-and-prev)
  (define-key evil-visual-state-map (kbd "M-D") 'evil-multiedit-and-prev)

  ;; OPTIONAL: If you prefer to grab symbols rather than words, use
  ;; `evil-multiedit-match-symbol-and-next` (or prev).

  ;; Restore the last group of multiedit regions.
  (define-key evil-visual-state-map (kbd "C-M-D") 'evil-multiedit-restore)

  ;; RET will toggle the region under the cursor
  (define-key evil-multiedit-state-map (kbd "RET") 'evil-multiedit-toggle-or-restrict-region)

  ;; ...and in visual mode, RET will disable all fields outside the selected region
  (define-key evil-motion-state-map (kbd "RET") 'evil-multiedit-toggle-or-restrict-region)

  ;; For moving between edit regions
  (define-key evil-multiedit-state-map (kbd "C-n") 'evil-multiedit-next)
  (define-key evil-multiedit-state-map (kbd "C-p") 'evil-multiedit-prev)
  (define-key evil-multiedit-insert-state-map (kbd "C-n") 'evil-multiedit-next)
  (define-key evil-multiedit-insert-state-map (kbd "C-p") 'evil-multiedit-prev))

  #+END_SRC 
           ;; :bind (:map evil-visual-state-map 
           ;;             ;; Highlights all matches of the selection in the buffer.
           ;;             ("R" . evil-multiedit-match-all)
           ;;             ;; Match selected region.
           ;;             ("M-d" . evil-multiedit-and-next)
           ;;             ;; Same as M-d but in reverse.
           ;;             ("M-D" . evil-multiedit-and-prev)
           ;;             ;; Restore the last group of multiedit régions.
           ;;             ;;("C-M-D" . evil-multiedit-restore)
           ;;             :map evil-normal-state-map 
           ;;             ;; Match the word under cursor (i.e. make it an edit region). Consecutive presses will
           ;;             ;; incrementally add the next unmatched match.
           ;;             ("M-d" . evil-multiedit-match-and-next)
           ;;             ;; Same as M-d but in reverse.
           ;;             ("M-D" . evil-multiedit-match-and-prev)
           ;;             :map evil-insert-state-map 
           ;;             ;; Insert marker at point
           ;;             ("M-d" . evil-multiedit-toggle-marker-here)
           ;;             :map evil-multiedit-state-map 
           ;;             ;; RET will toggle the region under the cursor
           ;;             ("RET" . evil-multiedit-toggle-or-restrict-region)
           ;;             ;; For moving between edit régions
           ;;             ("C-n" . evil-multiedit-next)
           ;;             ("C-p" . evil-multiedit-prev)
           ;;             :map evil-motion-state-map
           ;;             ;; ...and in visual mode, RET will disable all fields outside the selected region
           ;;             ("RET" . evil-multiedit-toggle-or-restrict-region)
           ;;             :map evil-multiedit-insert-state-map
           ;;             ;; For moving between edit régions
           ;;             ("C-n" . evil-multiedit-next)
           ;;             ("C-p" . evil-multiedit-prev)))
          ;; :config
           ;; Ex command that allows you to invoke evil-multiedit with a regular expression, e.g.
           ;;(evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match))
*** 取 EVIL multiple cursors
;;(require 'evil-mc)
;;(global-evil-mc-mode  1)
;;(define-key evil-mc-key-map (kbd "C->") 'evil-mc-make-and-goto-next-match)
;;(define-key evil-mc-key-map (kbd "M->") 'evil-mc-skip-and-goto-next-cursor)
;;(define-key evil-mc-key-map (kbd "M->") 'evil-mc-make-and-goto-next-cursor)
;;(define-key evil-mc-key-map (kbd "C-<") 'evil-mc-make-and-goto-prev-match)
;;(define-key evil-mc-key-map (kbd "M-<") 'evil-mc-skip-and-goto-prev-cursor)
;;(define-key evil-mc-key-map (kbd "M-<") 'evil-mc-make-and-goto-prev-cursor)
** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile :after ivy
  :config
  (progn
    (setq projectile-keymap-prefix (kbd "C-p"))
    (setq projectile-completion-system 'ivy)
    (setq projectile-enable-caching t)
    ;;(setq projectile-indexing-method 'alien)
    (add-to-list 'projectile-globally-ignored-files "node-modules"))
  :config
  (projectile-mode))
#+END_SRC
** Swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper 
:bind
(("C-s" . swiper)))
#+END_SRC
** Counsel
#+BEGIN_SRC emacs-lisp
(use-package counsel 
:bind
(("M-x" . counsel-M-x)
("M-y" . counsel-yank-pop)
("C-x C-f" . counsel-find-file)
("<f5>" . counsel-recentf)
("<f1> f" . counsel-describe-function)
("<f1> v" . counsel-describe-variable)
("<f1> l" . counsel-load-library)
("<f2> i" . counsel-info-lookup-symbol)
("<f2> u" . counsel-unicode-char)))
#+END_SRC
** Ivy 
#+BEGIN_SRC emacs-lisp
(use-package ivy
:init
(progn
(setq ivy-use-virtual-buffers t)
(setq ivy-count-format "(%d/%d) "))
:config
(add-hook 'after-init-hook 'ivy-mode))
#+END_SRC
** Org-mode 
*** Capture mode
#+BEGIN_SRC emacs-lisp
  (setq org-default-notes-file "~/Dropbox/org/todo.org")
  ;;(setq org-default-notes-file "~/Dropbox/org/todo.org")
  (define-key global-map "\C-cc" 'org-capture)

  (defvar org-capture-templates '(
                                  ("t" "Tache" entry
                                   (file+olp "~/Dropbox/org/todo.org" "Tasks" "Indéfini")
                                   "*** 無 %^{Tache} \n:PROPERTIES:\n:ADDED: %<[%Y-%m-%d]>\n:END:" :prepend t)
                                  ("s" "Tache d'etude" entry
                                   (file+olp "~/Dropbox/org/todo.org" "Tasks" "Études" "Indéfini")
                                   "**** 無 %^{Tache d'etude} %^g \n:PROPERTIES:\n:ADDED: %<[%Y-%m-%d]>\n:END:" :prepend t)
                                          ;("r" "Tache de révision" entry
                                          ; (file+headline "~/Dropbox/projects/paris_1/m1_2_notes.org" "Undefiniert")
                                          ; "*** 無 %^{Tache de révision} %^{Type de tâche|:review:|:reading:|:project:|:exam:} \nCreated: %<[%Y-%m-%d]>")
                                  ("i" "Idée" entry
                                   (file+headline "~/Dropbox/org/todo.org" "Ideas")
                                   "** %^{idea_title} \n:PROPERTIES:\n:ADDED: %<[%Y-%m-%d]>\n:TRACE: %a\n:END:" :prepend t)
                                  ("e" "Idée d'Emacs" entry
                                   (file+headline "~/Dropbox/org/todo.org" "Emacs")
                                   "** %^{idea_title} \n:PROPERTIES:\n:ADDED: %<[%Y-%m-%d]>\n:TRACE: %a\n:END:" :prepend t)
                                  ("q" "Question" entry
                                   (file+headline "~/Dropbox/org/todo.org" "Questions")
                                   "** %^{question} \n:PROPERTIES:\n:ADDED: %<[%Y-%m-%d]>\n:TRACE: %a\n:END:" :prepend t)
                                  ("a" "Auteur" entry
                                   (file "~/Dropbox/org/master.org")
                                   "* %^{last_name,first_name} :lecture: \n:ORIGIN:\n%^{Where?}\n:END:\n:PROPERTIES:\n:ADDED: %<[%Y-%m-%d]>\n:END:" :prepend t)
                                  ("b" "Book (todo)" entry
                                   (file+headline "~/Dropbox/org/todo.org" "Books")
                                   "** %^{book_title}\n:ORIGIN:\n%^{Where?}\n:END:\n:PROPERTIES:\n:ADDED: %<[%Y-%m-%d]>\n:TRACE: %a\n:END:\n" :prepend t)
                                  ("r" "New Reading (master)" entry
                                   (file "~/Dropbox/org/master.org")
                                   "* %^{reading_title}\n:ORIGIN:\n%^{Where?}\n:END:\n:PROPERTIES:\n:YEAR:\n:JOURNAL:\n:VOLUME:\n:ISSUE:\n:PAGES:\n:ADDED: %<[%Y-%m-%d]>\n:TRACE: %a\n:END:\n" :prepend t)
                                  )) 
#+END_SRC 
**** Another settings
(defvar org-capture-templates
       '(("t" "todo" entry (file org-default-notes-file)
       "*** 無 %?\n%u\n%a\n" :clock-in t :clock-resume t)
	 ("b" "Blank" entry (file org-default-notes-file)
	  "*** %?\n%u")
	 ("m" "Meeting" entry (file org-default-notes-file)
	  "* MEETING with %? :MEETING:\n%t" :clock-in t :clock-resume t)
	 ;;("d" "Diary" entry (file+datetree "~/org/diary.org")
	  ;;"* %?\n%U\n" :clock-in t :clock-resume t)
	 ;;("D" "Daily Log" entry (file "~/org/daily-log.org")
	  ;;"* %u %?\n*Summary*: \n\n*Problem*: \n\n*Insight*: \n\n*Tomorrow*: " :clock-in t :clock-resume t)
	 ("i" "Idea" entry (file org-default-notes-file)
	  "* %? :IDEA: \n%u" :clock-in t :clock-resume t)
))


(setq org-capture-templates
      '(("a" "Appointment" entry (file  "~/Dropbox/orgfiles/gcal.org" )
	 "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")
	("l" "Link" entry (file+headline "~/Dropbox/orgfiles/links.org" "Links")
	 "* %? %^L %^g \n%T" :prepend t)
	("b" "Blog idea" entry (file+headline "~/Dropbox/orgfiles/i.org" "Blog Topics:")
	 "* %?\n%T" :prepend t)
	("t" "To Do Item" entry (file+headline "~/Dropbox/orgfiles/i.org" "To Do")
	 "* TODO %?\n%u" :prepend t)
	("n" "Note" entry (file+headline "~/Dropbox/orgfiles/i.org" "Note space")
	 "* %?\n%u" :prepend t)
	("j" "Journal" entry (file+datetree "~/Dropbox/journal.org")
	 "* %?\nEntered on %U\n  %i\n  %a")
	("s" "Screencast" entry (file "~/Dropbox/orgfiles/screencastnotes.org")
	 "* %?\n%i\n")))

  (setq org-capture-templates
        `(("t" "Tasks" entry
           (file+headline "~/personal/organizer.org" "Inbox")
           ,my/org-basic-task-template)
          ("T" "Quick task" entry
           (file+headline "~/personal/organizer.org" "Inbox")
           "* TODO %^{Task}\nSCHEDULED: %t\n"
           :immediate-finish t)
          ("i" "Interrupting task" entry
           (file+headline "~/personal/organizer.org" "Inbox")
           "* STARTED %^{Task}"
           :clock-in :clock-resume)
          ("e" "Emacs idea" entry
           (file+headline "~/code/emacs-notes/tasks.org" "Emacs")
           "* TODO %^{Task}"
           :immediate-finish t)

create a template that prompts for a todo study task with task completion and add automatically the time it was added. 

emacs idea 
basic todo
study todo
question 
idea 


;; == Capture Mode Settings ==
;; Define the custum capture templates
(defvar org-capture-templates 


(defvar org-capture-templates '(
             ("t" "Tâche" entry (file+headline "~/Dropbox/org/todo.org" "Université")
              "**** 無 %?")
("a" "Appointment" entry (file  "~/Dropbox/org/gcal.org" )
	 "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")
	 ("b" "Blank" entry (file org-default-notes-file)
	  "**** %?")
	 ;;("m" "Meeting" entry (file org-default-notes-file)
	  ;;"* MEETING with %? :MEETING:\n%t" :clock-in t :clock-resume t)
	 ;;("d" "Diary" entry (file+datetree "~/org/diary.org")
	  ;;"* %?\n%U\n" :clock-in t :clock-resume t)
	 ;;("D" "Daily Log" entry (file "~/org/daily-log.org")
	  ;;"* %u %?\n*Summary*: \n\n*Problem*: \n\n*Insight*: \n\n*Tomorrow*: " :clock-in t :clock-resume t)
	 ("i" "Idea" entry (file+headline "~/Dropbox/org/todo.org" "Idées")
	  "*** %? :Idea: \n%u" :prepend t)
))

*** Tags
#+BEGIN_SRC emacs-lisp
  (setq org-tag-alist '(
                        ("exam" . ?e)
                        ("project" . ?p)
                        ("reading" . ?r)
                        ("review" . ?v)
                        ("chores" . ?c)
                        ("today" . ?h)
                        ("idea" . ?i)
                        ("memoire" . ?m)
                        ("thesis" . ?t)
                        ("question" . ?q)
                        ("noexport" . ?n)
                        ("university" . ?u)
                        ))

  ;; Allow setting single tags without the menu
  ;;(setq org-fast-tag-selection-single-key 'expert)

#+END_SRC 
*** Agenda
#+BEGIN_SRC emacs-lisp
      ;; specify agenda files
      (setq org-agenda-files (list "~/Dropbox/org/gcal.org"
                                   "~/Dropbox/org/unterrichte.org"
                                   "~/Dropbox/org/refile-beorg.org"
                                   "~/Dropbox/org/ereignisse.org"
                                   ;;                                    "~/Dropbox/org/gewohnheiten.org"
                                   "~/Dropbox/paris_1/m2_1"
                                   "~/Dropbox/paris_1/memoire"
                                   "~/Dropbox/org/jahrestage.org"
                                   "~/Dropbox/org/master.org"
                                   "~/Dropbox/org/todo.org"))

      ;; necessary function 1
      (defun air-org-skip-subtree-if-priority (priority)
        "Skip an agenda subtree if it has a priority of PRIORITY.
          PRIORITY may be one of the characters ?A, ?B, or ?C."
        (let ((subtree-end (save-excursion (org-end-of-subtree t)))
              (pri-value (* 1000 (- org-lowest-priority priority)))
              (pri-current (org-get-priority (thing-at-point 'line t))))
          (if (= pri-value pri-current)
              subtree-end
            nil)))

      ;; necessary function 2
      (defun air-org-skip-subtree-if-habit ()
        "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (if (string= (org-entry-get nil "STYLE") "habit")
              subtree-end
            nil)))

      ;; build composite agenda view
      (setq org-agenda-custom-commands
            '(
              ;;("n" "power agenda" ((agenda  "") (alltodo))
              ;;                ((org-agenda-ndays 10)
              ;;	                   (org-agenda-start-on-weekday nil)
              ;;	                   (org-agenda-start-day "-1d")))
              ("d" "Deux semaines" (
                                    (agenda "" ((org-agenda-overriding-header "Today's Schedule:")
                                                (org-agenda-span 'day)
                                                (org-agenda-start-day "+0d")
                                                (org-agenda-prefix-format " %-12t%-12s %-30b ")
  ;; This format calls for two consecutive 12-character fields for time (%t)
  ;; and scheduling information(%s), followed by a 30-character field for the
  ;; breadcrumbs (the path). The reason for using fixed fields is to improve
  ;; readability of the colums. Otherwise, apending and ~?~ character as in
  ;; ~%?t~, only adds the field if the category exists. While this sound like
  ;; a smart idea to save space, its very unreadable, so I advise against
  ;; using it. This format is applied equally to the next two sections,
  ;; precisely to avoid illegible output.
                                                (org-agenda-start-on-weekday nil)))
                                    ;; (org-agenda-todo-ignore-deadlines nil)))
                                    (agenda "" ((org-agenda-overriding-header "Prochains 7 jours:")
                                                (org-agenda-span 'week)
                                                (org-agenda-start-day "+1d")
                                                (org-agenda-start-on-weekday nil)
                                                ;; (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
                                                (org-agenda-prefix-format " %-12t%-12s %-30b ")))
                                    (agenda "" ((org-agenda-overriding-header "Prochains 14 jours:")
                                                (org-agenda-span 'week)
                                                (org-agenda-start-day "+8d")
                                                (org-agenda-start-on-weekday nil)
                                                ;; (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
                                                (org-agenda-prefix-format " %-12t%-12s %-30b "))))
               ;; list options for block display
               ((org-agenda-compact-blocks nil)
               (org-agenda-view-columns-initially t)))
              ;; ("H" "A user's setup" (
              ;;                              (agenda "" ((org-agenda-overriding-header "Today's Schedule:")
              ;;                                          (org-agenda-span 'day)
              ;;                                          (org-agenda-ndays 14)
              ;;                                          (org-agenda-start-on-weekday nil)
              ;;                                          (org-agenda-start-day "+0d")
              ;;                                          (org-agenda-todo-ignore-deadlines nil)))
              ;;                              (tags-todo "university/!+次|+待|+中"
              ;;                                         ((org-agenda-overriding-header "Current University Tasks:")
              ;;                                          ))
              ;;                              (tags-todo "university/!+無"
              ;;                                         ((org-agenda-overriding-header "Undone University Tasks:")
              ;;                                          ))
              ;;                              (agenda "" ((org-agenda-overriding-header "Week At A Glance:")
              ;;                                          (org-agenda-ndays 7)
              ;;                                          (org-agenda-start-day "+1d")
              ;;                                          (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
              ;;                                          (org-agenda-prefix-format '((agenda . "  %-12:c%?-12t %s [%b] ")))))
              ;;                              ))

              ;; ("d" "Daily agenda and all TODOs"
              ;;  ((tags "PRIORITY=\"A\""
              ;;         ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
              ;;          (org-agenda-overriding-header "High-priority unfinished tasks:")))
              ;;   (agenda "" ((org-agenda-ndays 1)))
              ;;   (alltodo ""
              ;;            ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
              ;;                                            (air-org-skip-subtree-if-priority ?A)
              ;;                                            (org-agenda-skip-if nil '(scheduled deadline))))
              ;;             (org-agenda-overriding-header "ALL normal priority tasks:"))))
              ;;  ;; list of crazy options
              ;;  ((org-agenda-compact-blocks t)))

              ("w" "Study Planner" (
                                    (tags-todo "review/!+次|+待|+中|+無|+阻"
                                               ((org-agenda-overriding-header "Revisions:")))
                                    (tags-todo "reading/!+次|+待|+中|+無|+阻"
                                               ((org-agenda-overriding-header "Lectures:")))
                                    (tags-todo "project/!+次|+待|+中|+無|+阻"
                                               ((org-agenda-overriding-header "Projects:")))
                                    (tags-todo "exam/!+次|+待|+中|+無|+阻"
                                               ((org-agenda-overriding-header "Examens:"))))
               ;; list options for block display
               ((org-agenda-compact-blocks t)
                (org-agenda-view-columns-initially t)))

              ;;("h" "Aujourd'hui" (
              ;;         (tags-todo "review&today/!+次|+待|+中|+無"
              ;;                                                           ((org-agenda-overriding-header "Révisions:")))
              ;;       (tags-todo "reading&today/!+次|+待|+中|+無"
              ;;                                                         ((org-agenda-overriding-header "Lectures:")))
              ;;     (tags-todo "project&today/!+次|+待|+中|+無"
              ;;                                                      ((org-agenda-overriding-header "Projects:")))
              ;; (tags-todo "exam&today/!+次|+待|+中|+無"
              ;;                                                  ((org-agenda-overriding-header "Examens:"))))
              ;; list options for block display
              ;;  ((org-agenda-compact-blocks t)
              ;; (org-agenda-view-columns-initially t)))

              ("x" "Tâches: Toutes" (
                                     (tags "PRIORITY=\"A\""
                                           ((org-agenda-skip-function '(or (org-agenda-skip-entry-if 'todo '("完" "取"))
                                                                           (air-org-skip-subtree-if-habit)))
                                                 (org-agenda-prefix-format " %s [%?-45b] ")
                                            (org-agenda-overriding-header "Tâches prioritaires:")))
                                     (alltodo ""
                                              ((org-agenda-skip-function '(or (org-agenda-skip-entry-if 'nottodo '("中" "次"))
                                                                              ;; (air-org-skip-subtree-if-habit)
                                                                              (air-org-skip-subtree-if-priority ?A)))
                                                 (org-agenda-prefix-format " %s [%?-45b] ")
                                               ;;(org-agenda-skip-if nil '(scheduled deadline))
                                               (org-agenda-overriding-header "Tâches en cours:")))
                                     (alltodo ""
                                              ((org-agenda-skip-function '(or (org-agenda-skip-entry-if 'nottodo '("無"))
                                                                              ;; (air-org-skip-subtree-if-habit)
                                                                              ;;(org-agenda-skip-if nil '(scheduled deadline))
                                                                              (air-org-skip-subtree-if-priority ?A)))
                                                 (org-agenda-prefix-format " %s [%?-45b] ")
                                               (org-agenda-overriding-header "Tâches à faire:")))
                                     (alltodo ""
                                              ((org-agenda-skip-function '(or (org-agenda-skip-entry-if 'nottodo '("待"))
                                                                              ;; (air-org-skip-subtree-if-habit)
                                                                              (air-org-skip-subtree-if-priority ?A)))
                                               ;;(org-agenda-skip-if nil '(scheduled deadline))))
                                                 (org-agenda-prefix-format " %s [%?-45b] ")
                                               (org-agenda-overriding-header "Tâches en attente:")))
                                     (alltodo ""
                                              ((org-agenda-skip-function '(or (org-agenda-skip-entry-if 'nottodo '("阻"))
                                                                              ;; (air-org-skip-subtree-if-habit)
                                                                              (air-org-skip-subtree-if-priority ?A)))
                                                 (org-agenda-prefix-format " %s [%?-45b] ")
                                               (org-agenda-overriding-header "Tâches coincées:"))))
               ;; list options for block display
               ((org-agenda-compact-blocks t)))

              ("y" "Tâches: Université" (
                                         (tags-todo "+lecture+PRIORITY=\"A\"|+university+PRIORITY=\"A\"|+work+PRIORITY=\"A\""
                                                    ((org-agenda-skip-function '(or (org-agenda-skip-entry-if 'todo '("完" "取"))
                                                                                    (air-org-skip-subtree-if-habit)))
                                                 (org-agenda-prefix-format " %s [%?-45b] ")
                                                     (org-agenda-overriding-header "Tâches prioritaires:")))
                                         (tags-todo "+lecture|+university|+work"
                                                    ((org-agenda-skip-function '(or (org-agenda-skip-entry-if 'nottodo '("中" "次"))
                                                                                    (air-org-skip-subtree-if-habit)
                                                                                    (air-org-skip-subtree-if-priority ?A)))
                                                 (org-agenda-prefix-format " %s [%?-45b] ")
                                                     ;;(org-agenda-skip-if nil '(scheduled deadline))
                                                     (org-agenda-overriding-header "Tâches en cours:")))
                                         (tags-todo "+lecture|+university|+work"
                                                    ((org-agenda-skip-function '(or (org-agenda-skip-entry-if 'nottodo '("無"))
                                                                                    (air-org-skip-subtree-if-habit)
                                                                                    ;;(org-agenda-skip-if nil '(scheduled deadline))
                                                                                    (air-org-skip-subtree-if-priority ?A)))
                                                 (org-agenda-prefix-format " %s [%?-45b] ")
                                                     (org-agenda-overriding-header "Tâches à faire:")))
                                         (tags-todo "+lecture|+university|+work"
                                                    ((org-agenda-skip-function '(or (org-agenda-skip-entry-if 'nottodo '("待"))
                                                                                    (air-org-skip-subtree-if-habit)
                                                                                    (air-org-skip-subtree-if-priority ?A)))
                                                     ;;(org-agenda-skip-if nil '(scheduled deadline))))
                                                 (org-agenda-prefix-format " %s [%?-45b] ")
                                                     (org-agenda-overriding-header "Tâches en attente:")))
                                         (tags-todo "+lecture|+university|+work"
                                                    ((org-agenda-skip-function '(or (org-agenda-skip-entry-if 'nottodo '("阻"))
                                                                                    (air-org-skip-subtree-if-habit)
                                                                                    (air-org-skip-subtree-if-priority ?A)))
                                                 (org-agenda-prefix-format " %s [%?-45b] ")
                                                     (org-agenda-overriding-header "Tâches coincées:"))))
               ;; list options for block display
               ((org-agenda-compact-blocks t)
    (org-agenda-view-columns-initially t)))
    ;; End of custom
              ))

      ;; Display properties
      (setq org-cycle-separator-lines 0
            ;; Choose the placement of org tags in org files.
            org-tags-column 80
            ;; Place org agenda tags in the same place as org tags.
            org-agenda-tags-column org-tags-column
            ;; Make org-agenda the only window by default.
            org-agenda-window-setup 'only-window 
            ;; Build agenda manually (to update press "r").
            org-agenda-sticky t
            ;; Compact the block agenda view. This deletes the section separators.
            org-agenda-compact-blocks nil
            ;; Allow one-key todo selection.
            org-use-fast-todo-selection t 
            ;; Include the todo keywords in fast tag selection buffer.
            org-fast-tag-selection-include-todo t
            ;; Allow one-key tag selection.
           org-fast-tag-selection-single-key t
  ;; each habit to show up when it is next scheduled, but no further repetitions
    org-agenda-repeating-timestamp-show-all nil
    ;; Add appointments duration to column view's effort estimates.
     org-agenda-columns-add-appointments-to-effort-sum t)


      ;; Set of functions to have evil bindings in org-agenda.

      (defun air-org-agenda-next-header ()
        "Jump to the next header in an agenda series."
        (interactive)
        (air--org-agenda-goto-header))

      (defun air-org-agenda-previous-header ()
        "Jump to the previous header in an agenda series."
        (interactive)
        (air--org-agenda-goto-header t))

      (defun air--org-agenda-goto-header (&optional backwards)
        "Find the next agenda series header forwards or BACKWARDS."
        (let ((pos (save-excursion
                     (goto-char (if backwards
                                    (line-beginning-position)
                                  (line-end-position)))
                     (let* ((find-func (if backwards
                                           'previous-single-property-change
                                         'next-single-property-change))
                            (end-func (if backwards
                                          'max
                                        'min))
                            (all-pos-raw (list (funcall find-func (point) 'org-agenda-structural-header)
                                               (funcall find-func (point) 'org-agenda-date-header)))
                            (all-pos (cl-remove-if-not 'numberp all-pos-raw))
                            (prop-pos (if all-pos (apply end-func all-pos) nil)))
                       prop-pos))))
          (if pos (goto-char pos))
          (if backwards (goto-char (line-beginning-position)))))

      ;; fast access agenda view
      (defun air-pop-to-org-agenda (&optional split)
        "Visit the org agenda, in the current window or a SPLIT."
        (interactive "P")
        (org-agenda nil "d") ;; the h corresponds to the agenda view that will be displayed once this command is called
        (when (not split)
          (delete-other-windows)))

      ;;(define-key evil-normal-state-map (kbd "S-SPC") 'air-pop-to-org-agenda)
      (global-set-key [f6] 'air-pop-to-org-agenda)

      ;; sacha's configuration 
      (defun sacha/org-agenda-new ()
        "Create a new note or task at the current agenda item.
          Creates it at the same level as the previous task, so it's better to use
          this with to-do items than with projects or headings."
        (interactive)
        (org-agenda-switch-to)
        (org-capture 0))

      (defun sacha/org-agenda-mark-done-and-add-followup ()
        "Mark the current TODO as done and add another task after it.
          Creates it at the same level as the previous task, so it's better to use
          this with to-do items than with projects or headings."
        (interactive)
        (org-agenda-todo "DONE")
        (org-agenda-switch-to)
        (org-capture 0 "t"))
 #+END_SRC
****   Movement in agenda buffer
#+BEGIN_SRC emacs-lisp
  (eval-after-load "org-agenda"
    '(progn
       (define-key org-agenda-mode-map "j" 'org-agenda-next-item)
       (define-key org-agenda-mode-map "k" 'org-agenda-previous-item)
       (define-key org-agenda-mode-map "J" 'air-org-agenda-next-header)
       (define-key org-agenda-mode-map "K" 'air-org-agenda-previous-header)
       ;; New key assignment
       (define-key org-agenda-mode-map "N" 'sacha/org-agenda-new)
       ;; Override the key définition
       (define-key org-agenda-mode-map "X" 'sacha/org-agenda-mark-done-and-add-followup)
       ))
 #+END_SRC
**** Filter tags in agenda view 
This allow to hide certain tags in the agenda display, but include them in
the processing of agenda commands
#+BEGIN_SRC emacs-lisp
(setq org-agenda-hide-tags-regexp "noexport\\|today")
;;(setq org-agenda-hide-tags-regexp "noexport\\|university\\|today")
  #+END_SRC 
**** Habits
There is a strange inconsistency when habits are enabled. See [[https://emacs.stackexchange.com/questions/26291/not-allowed-in-tags-type-agenda-using-custom-agenda]]
#+BEGIN_SRC emacs-lisp
  (use-package org-habit :after org
  ;; :commands org-bullets-mode
  :config
  (setq org-habit-graph-column 80) 
  (setq org-habit-show-habits-only-for-today nil)
       (define-key org-agenda-mode-map "K" 'air-org-agenda-previous-header))
  #+END_SRC 
**** Visualization
#+BEGIN_SRC emacs-lisp
  ;; Hide inherited tags from Org's agenda view.
  ;;(setq org-agenda-show-inherited-tags nil)
  #+END_SRC 
**** Stuck projects 
     ;; (setq org-stuck-projects      '("TODO={.+}/-DONE" nil nil "SCHEDULED:\\|DEADLINE:"))
*** org-refile  
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets (quote ( 
                                   (nil :maxlevel . 9)                ;; set default 
                                   ("m2_1_notes.org" :maxlevel . 3)
                                   ("todo.org" :maxlevel . 2)
                                   ;;(org-agenda-files :maxlevel . 9) ;; set for all agenda files
                                   )))

  (setq org-refile-use-outline-path 'file
        ;; org-refile-use-outline-path nil ;; Sasha-Chua's config
        org-outline-path-complete-in-steps nil
        ;; org-reverse-note-order t
        org-refile-allow-creating-parent-nodes 'confirm
        org-refile-use-cache nil
        ;;org-blank-before-new-entry nil
        )
  #+END_SRC 
*** Clocking
#+BEGIN_SRC emacs-lisp
 ;; Agenda clock report parameters
  (setq org-agenda-clockreport-parameter-plist
        '(:link t :maxlevel 6 :fileskip0 t :compact t :narrow 60 :score 0))

  ;; If idle for more than 15 minutes, resolve the things by asking what to do
  ;; with the clock time
  (setq org-clock-idle-time 15)

  ;; global Effort estimate values
  (setq org-global-properties
        '(("Effort_ALL" .
           "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")))
  ;;        1    2    3    4    5    6    7    8    9    0
  ;; These are the hotkeys ^

  ;; Set default column view headings: Task Priority Effort Clock_Summary
  (setq org-columns-default-format "%1PRIORITY %ITEM(Task)  %DEADLINE %10EFFORT(Effort){:} %10CLOCKSUM")
  ;; (setq org-columns-default-format "%TAGS %ITEM(Task) %1PRIORITY %DEADLINE %SCHEDULED %10CLOCKSUM")
  ;;(setq org-columns-default-format "%50ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM %16TIMESTAMP_IA")
  ;;(setq org-columns-default-format "%50ITEM(Task) %2PRIORITY %10Effort(Effort){:} %10CLOCKSUM")

  ;; Show lot of clocking history so it's easy to pick items off the `C-c I` list
  (setq org-clock-history-length 23)

  (defun eos/org-clock-in ()
    (interactive)
    (org-clock-in '(4)))

  (global-set-key (kbd "C-c I") #'eos/org-clock-in)
  (global-set-key (kbd "C-c O") #'org-clock-out)

  ;; Resume clocking task when emacs is restarted
  (org-clock-persistence-insinuate)
  ;; Save the running clock and all clock history when exiting Emacs, load it on startup
  (setq org-clock-persist 'history)
  ;;(setq org-clock-persist t)
  ;; Resume clocking task on clock-in if the clock is open
  (setq org-clock-in-resume t)
  ;; Do not prompt to resume an active clock, just resume it
  (setq org-clock-persist-query-resume nil)

  ;; Change tasks to whatever when clocking in
  (setq org-clock-in-switch-to-state "中")
  ;; Save clock data and state changes and notes in the LOGBOOK drawer
  (setq org-clock-into-drawer t)
  ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks
  ;; with 0:00 duration
  (setq org-clock-out-remove-zero-time-clocks t)
  ;; Clock out when moving task to a done state
  (setq org-clock-out-when-done t)
  ;; Enable auto clock resolution for finding open clocks
  (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
  ;; Include current clocking task in clock reports
  (setq org-clock-report-include-clocking-task t)
  ;; use pretty things for the clocktable
  (setq org-pretty-entities t)
#+END_SRC 
*** Initial visualization
#+BEGIN_SRC emacs-lisp 
;; Initial indentation
(setq org-startup-indented nil)         

;; Begin displaying entire trees
;; (setq org-startup-folded nil) 

;; Better display of italics & bold
(setq org-hide-emphasis-markers t)
#+END_SRC
*** custom TODO states 
#+BEGIN_SRC emacs-lisp
(setq org-use-fast-todo-selection nil)
(setq org-todo-keywords 
          '((sequence "無" "次" "中" "待" "完")
            (sequence "阻" "取(c)")))
            ;;(sequence "疑(q)" "|" "答(a)")))
;; (sequence "待(w)" "次" "取(c)")
            ;;(sequence "待(w)" "|" "取(c)")

;; set faces for org-todo-keywords
(setq org-todo-keyword-faces
      '(("無" . (:foreground "#dc322f" :weight bold))
        ("完" . (:foreground "#859900" :weight bold))   
        ("疑" . (:foreground "#d33682" :weight bold))
        ("答" . (:foreground "#268bd2" :weight bold)) 
        ("待" . (:foreground "#cb4b16" :weight bold))
        ("取" . (:foreground "#6c71c4" :weight bold)) 
        ("中" . (:foreground "#b58900" :weight bold)) 
        ))

(defun gs/mark-next-done-parent-tasks-todo ()
 ;; "Visit each parent task and change 中 (or 完) states to 無."
  ;; Don't change the value if new state is "完"
  (let ((mystate (or (and (fboundp 'org-state)
                          (member state
				  (list "中" "無")))
                     (member (nth 2 (org-heading-components))
			     (list "中" "無")))))
    (when mystate
      (save-excursion
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) (list "中" "完"))
            (org-todo "無")))))))

(add-hook 'org-after-todo-state-change-hook 'gs/mark-next-done-parent-tasks-todo 'append)
#+END_SRC
*** Org-bullets
#+BEGIN_SRC emacs-lisp
  ;; (use-package org-bullets :after org
  ;; :commands org-bullets-mode
  ;; :init
  ;; (progn
  ;; (setq org-bullets-bullet-list '("一" "二" "三" "四" "五" "六" "七" "八" "七" "九" "十"))
  ;; (setq org-bullets-bullet-list '("一" "二" "三" "四" "五"))
  ;; (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))))
#+END_SRC 
*** Org-crypt
    #+BEGIN_SRC emacs-lisp
      (use-package org-crypt :after org
        :config
        (org-crypt-use-before-save-magic)
        (setq org-tags-exclude-from-inheritance (quote ("crypt"))
              org-crypt-key nil)
        ;; GPG key to use for encryption
        ;; Either the Key ID or set to nil to use symmetric encryption.
        )
      ;; (setq auto-save-default nil)
      ;; Auto-saving does not cooperate with org-crypt.el: so you need
      ;; to turn it off if you plan to use org-crypt.el quite often.
      ;; Otherwise, you'll get an (annoying) message each time you
      ;; start Org.

      ;; To turn it off only locally, you can insert this:
      ;;
      ;; # -*- buffer-auto-save-file-name: nil; -*-

      #+END_SRC 
*** hook flyspell into org-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'flyspell-mode)
;; (add-hook 'org-mode-hook 'flyspell-buffer)
#+END_SRC
*** 取 word count (experimental)
(eval-when-compile (require 'cl))
;; (require 'org)
(defun org-wc-in-heading-line ()
  "Is point in a line starting with `*'?"
  (equal (char-after (point-at-bol)) ?*))

;;;###autoload
(defun org-word-count (beg end)
  "Report the number of words in the Org mode buffer or selected region."
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (list (point-min) (point-max))))
  (message (format "%d words in %s."
                   (org-word-count-aux beg end)
                   (if (use-region-p) "region" "buffer"))))

(defun org-word-count-aux (beg end)
  "Report the number of words in the selected region.
Ignores: heading lines,
         blocks,
         comments,
         drawers.
LaTeX macros are counted as 1 word."

  (let ((wc 0)
        (latex-macro-regexp "\\\\[A-Za-z]+\\(\\[[^]]*\\]\\|\\){\\([^}]*\\)}"))
    (save-excursion
      (goto-char beg)
      (while (< (point) end)
        (cond
         ;; Ignore heading lines, and sections tagged 'nowc' or 'noexport'.
         ((org-wc-in-heading-line)
          (let ((tags (org-get-tags-at)))
            (if (or (member "nowc" tags)
                    (member "noexport" tags))
                (outline-next-heading)
              (forward-line))))
         ;; Ignore blocks.
         ((org-at-block-p)
          (goto-char (match-end 0)))
         ;; Ignore comments.
         ((org-at-comment-p)
          (forward-line))
         ;; Ignore drawers.
         ((org-at-drawer-p)
          (progn (goto-char (match-end 0))
                 (re-search-forward org-property-end-re end t)
                 (forward-line)))
         ;; Count latex macros as 1 word, ignoring their arguments.
         ((save-excursion
            (if (> (point-min) (point)) (backward-char) )
            (looking-at latex-macro-regexp))
          (goto-char (match-end 0))
          (setf wc (+ 2 wc)))
         (t
          (progn
            (and (re-search-forward "\\w+\\W*" end 'skip)
                 (incf wc)))))))
    wc))

;;;###autoload
(defun org-wc-count-subtrees ()
  "Count words in each subtree, putting result as the property :org-wc on that heading."
  (interactive)
  (remove-text-properties (point-min) (point-max)
                          '(:org-wc t))
  (save-excursion
    (goto-char (point-max))
    (while (outline-previous-heading)
      (save-restriction
        (org-narrow-to-subtree)
        (let ((wc (org-word-count-aux (point-min) (point-max))))
          (put-text-property (point) (point-at-eol) :org-wc wc)
          (goto-char (point-min)))))))

;;;###autoload
(defun org-wc-display (total-only)
  "Show subtree word counts in the entire buffer.
With prefix argument, only show the total wordcount for the buffer or region
in the echo area.

Use \\[org-wc-remove-overlays] to remove the subtree times.

Ignores: heading lines,
         blocks,
         comments,
         drawers.
LaTeX macros are counted as 1 word."
  (interactive "P")
  (let ((beg (if (region-active-p) (region-beginning) (point-min)))
        (end (if (region-active-p) (region-end) (point-max))))
  (org-wc-remove-overlays)
  (unless total-only
    (let ((bmp (buffer-modified-p))
          wc
          p)
      (org-wc-count-subtrees)
      (save-excursion
        (goto-char (point-min))
        (while (or (and (equal (setq p (point)) (point-min))
                        (get-text-property p :org-wc))
                   (setq p (next-single-property-change
                            (point) :org-wc)))
          (goto-char p)
          (when (setq wc (get-text-property p :org-wc))
            (org-wc-put-overlay wc (funcall outline-level))))
        ;; Arrange to remove the overlays upon next change.
        (when org-remove-highlights-with-change
          (org-add-hook 'before-change-functions 'org-wc-remove-overlays
                        nil 'local)))
    (set-buffer-modified-p bmp)))
  (org-word-count beg end)))

(defvar org-wc-overlays nil)
(make-variable-buffer-local 'org-wc-overlays)

(defun org-wc-put-overlay (wc &optional level)
  "Put an overlay on the current line, displaying word count.
If LEVEL is given, prefix word count with a corresponding number of stars.
This creates a new overlay and stores it in `org-wc-overlays', so that it
will be easy to remove."
  (let* ((c 60)
         (l (if level (org-get-valid-level level 0) 0))
         (off 0)
         ov tx)
    (org-move-to-column c)
    (unless (eolp) (skip-chars-backward "^ \t"))
    (skip-chars-backward " \t")
    (setq ov (make-overlay (1- (point)) (point-at-eol))
          tx (concat (buffer-substring (1- (point)) (point))
                     (make-string (+ off (max 0 (- c (current-column)))) ?.)
                     (org-add-props (format "%s" (number-to-string wc))
                         (list 'face 'org-wc-overlay))
                     ""))
    (if (not (featurep 'xemacs))
        (overlay-put ov 'display tx)
      (overlay-put ov 'invisible t)
      (overlay-put ov 'end-glyph (make-glyph tx)))
    (push ov org-wc-overlays)))

;;;###autoload
(defun org-wc-remove-overlays (&optional beg end noremove)
  "Remove the occur highlights from the buffer.
BEG and END are ignored.  If NOREMOVE is nil, remove this function
from the `before-change-functions' in the current buffer."
  (interactive)
  (unless org-inhibit-highlight-removal
    (mapc 'delete-overlay org-wc-overlays)
    (setq org-wc-overlays nil)
    (unless noremove
      (remove-hook 'before-change-functions
                   'org-wc-remove-overlays 'local))))

(provide 'org-wc)

(define-key org-mode-map "\C-c\C-w" 'org-word-count)
;; enable word count mode
; (add-hook 'org-mode-hook 'wc-mode)
*** Org2blog                                                                    
This package allow org mode to interact with WordPress. 
#+BEGIN_SRC emacs-lisp
  (use-package org2blog :after org 
    :config
;; initial config
    (setq load-path (cons "~/.emacs.d/org2blog/" load-path))
    (require 'org2blog-autoloads)
    (setq org-list-allow-alphabetical t)

  ;; blog setup
    (setq org2blog/wp-blog-alist
          '(("cahiers"
             :url "https://cyberneticrevolutionary.wordpress.com/xmlrpc.php"
             :username "cyberneticrevolutionary"
             :password "kosmos666"
             :default-title "Penseé"
             :tags-as-categories nil))))
#+END_SRC
**** default template
(setq org2blog/wp-buffer-template
      "-----------------------
#+TITLE: %s
#+DATE: %s
-----------------------\n")
(defun my-format-function (format-string)
  (format format-string
          org2blog/wp-default-title
          (format-time-string "%Y-%m-%d" (current-time)))))
          (setq org2blog/wp-buffer-format-function
'my-format-function)
*** keybindings
#+BEGIN_SRC emacs-lisp
;; fast insert drawer
;; (define-key org-mode-map (kbd "C-d") 'org-insert-drawer)
;; fast show in buffer
;; (define-key org-mode-map (kbd "C-b") 'org-tree-to-indirect-buffer)
#+END_SRC
*** export settings for LaTeX
#+BEGIN_SRC emacs-lisp
  ;; export references (to tables, graphics, etc.) properly, evaluating the +NAME property. 
  (setq org-latex-prefer-user-labels t)

  ;; export process is sent to the background
  (setq org-export-in-background t)

  ;; select tasks (i.e., TODOs) for export
  (setq org-export-with-tasks '("次" "完" "無" "中" "待" "疑"))

(defun sync0-latex-compile ()
    (save-buffer)
    (TeX-command "LaTeX" 'TeX-master-file))

  (defun sync0-latex-and-beamer-export ()
    "Export current org file with beamer if it has beamer as latex class."
    (interactive)
    (when (equal major-mode 'org-mode) 
        (if (string-match "LATEX_CLASS: beamer" (buffer-string))
            (org-beamer-export-to-pdf)
          (org-latex-export-to-pdf))
      ))

  ;; speed keybinding for latex pdf export
  ;;(global-set-key "\M-p" 'org-latex-export-to-pdf)
  (global-set-key "\M-p" 'sync0-latex-and-beamer-export)

                                          ;(add-hook 'org-mode-hook
                                          ;     (lambda () (define-key global-map "\M-p" 'org-latex-export-to-pdf)))
  ;;(lambda () (define-key org-mode-map "\M-p" 'org-latex-export-to-pdf)))

  ;; Default packages included in every tex file, pdflatex or xelatex
  ;;(setq org-latex-packages-alist
  ;;      '(("" "graphicx" t)
  ;;        ("" "longtable" nil)
  ;;        ("" "float" nil)))

  ;; source: https://lists.gnu.org/archive/html/emacs-orgmode/2013-06/msg00240.html
  (defun my-auto-tex-cmd (backend)
    "When exporting from .org with latex,
      automatically run latex, pdflatex, or xelatex as appropriate,
      using latexmk."
    (let ((texcmd))
      (setq texcmd "latexmk -pdf %f")
      (if (string-match "LATEX_CMD: pdflatex" (buffer-string))
          (progn
            (setq texcmd "latexmk -pdf -pdflatex='pdflatex -file-line-error --shell-escape -synctex=1' %f")
            (setq org-latex-default-packages-alist
                  '(("AUTO" "inputenc" t)
                    ("T1"   "fontenc"   t)
                    (""     "fixltx2e"  nil)
                    (""     "wrapfig"   nil)
                    (""     "soul"      t)
                    (""     "textcomp"  t)
                    (""     "marvosym"  t)
                    (""     "wasysym"   t)
                    (""     "latexsym"  t)
                    (""     "amssymb"   t)
                    (""     "hyperref"  nil)))))
      (if (string-match "LATEX_CMD: xelatex" (buffer-string))
          (progn
            (setq texcmd "latexmk -pdflatex='xelatex -file-line-error --shell-escape -synctex=1' -pdf %f")
            (setq org-latex-default-packages-alist
                  '(("" "fontspec" t)
                    ("" "xunicode" t)
                    ("" "url" t)
                    ;; ("" "rotating" t)
                    ;; ("" "memoir-article-styles" t)
                    ;; ("american" "babel" t)
                    ;; ("babel" "csquotes" t)
                    ;; ("" "listings" nil)
                    ;; ("svgnames" "xcolor" t)
                    ("" "soul" t)
                    ;;("xetex, colorlinks=true, urlcolor=FireBrick, plainpages=false, pdfpagelabels, bookmarksnumbered" "hyperref" nil)
                    ))
            (setq org-latex-classes
                  (cons '("memarticle"
                          "\\documentclass[12pt,oneside,article]{memoir}"
                          ("\\section{%s}" . "\\section*{%s}")
                          ("\\subsection{%s}" . "\\subsection*{%s}")
                          ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                          ("\\paragraph{%s}" . "\\paragraph*{%s}")
                          ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
                        org-latex-classes))))

      (setq org-latex-pdf-process (list texcmd))))
  (add-hook 'org-export-before-parsing-hook 'my-auto-tex-cmd)
#+END_SRC
*** Export to Word (doc)
#+BEGIN_SRC emacs-lisp
;; This setup is tested on Emacs 24.3 & Emacs 24.4 on Linux/OSX
;; org v7 bundled with Emacs 24.3
(setq org-export-odt-preferred-output-format "doc")
;; org v8 bundled with Emacs 24.4
(setq org-odt-preferred-output-format "doc")
;; BTW, you can assign "pdf" in above variables if you prefer PDF format

;; for page breaks add this to org files
;; #+ODT: <text:p text:style-name="PageBreak"/>
#+END_SRC 
*** Add custom LaTeX export classes
#+BEGIN_SRC emacs-lisp
;; KOMA-Script classes
(require 'ox-latex)
(with-eval-after-load 'ox-latex
(add-to-list 'org-latex-classes
         '("scrartcl"
             "\\documentclass{scrartcl}"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
(add-to-list 'org-latex-classes
         '("scrreprt"
             "\\documentclass{scrreprt}"
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
(add-to-list 'org-latex-classes
         '("scrbook"
             "\\documentclass{scrbook}"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
)
#+END_SRC
*** Custom add org headings
#+BEGIN_SRC emacs-lisp
(setq org-blank-before-new-entry
      '((heading . nil)
       (plain-list-item . nil)))

(defun call-rebinding-org-blank-behaviour (fn)
  (let ((org-blank-before-new-entry
         (copy-tree org-blank-before-new-entry)))
    (when (org-at-heading-p)
      (rplacd (assoc 'heading org-blank-before-new-entry) nil))
    (call-interactively fn)))

(defun smart-org-meta-return-dwim ()
  (interactive)
  (call-rebinding-org-blank-behaviour 'org-meta-return))

(defun smart-org-insert-todo-heading-dwim ()
  (interactive)
  (call-rebinding-org-blank-behaviour 'org-insert-todo-heading))

(define-key org-mode-map (kbd "M-<return>") 'smart-org-meta-return-dwim)
#+END_SRC
*** MobileOrg
;; Set to the location of your Org files on your local system
(setq org-directory "~/Dropbox/org")
;; Set to the name of the file where new notes will be stored
(setq org-mobile-inbox-for-pull "~/Dropbox/org/moborg_notes.org")
;; Set to <your Dropbox root directory>/MobileOrg.
(setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
*** Change default apps 
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
           '(lambda ()
            (delete '("\\.pdf\\'" . default) org-file-apps)
            (add-to-list 'org-file-apps '("\\.pdf\\'" . "mendeleydesktop %s"))))
#+END_SRC   
*** Editing source code
#+BEGIN_SRC emacs-lisp
;; color embeded source code
(setq org-src-fontify-natively t)

;; stop emacs asking for confirmation
(setq org-confirm-babel-evaluate nil)

;; export colored code blocks
(setq org-latex-listings 'minted)

;; set word wrap for code blocks
(setq org-latex-minted-options '(("breaklines" "true")
                                 ("breakanywhere" "true")))
#+END_SRC 
*** Code  export
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-export-exclude-tags "取")
#+END_SRC 
** Ivy-bibtex
         bibtex-completion-library-path '("~/Documents/mendeley/")
         bibtex-completion-pdf-field "file"
#+BEGIN_SRC emacs-lisp
  (use-package ivy-bibtex :after (org ivy)
    :config
    (setq ivy-bibtex-bibliography "~/Documents/mendeley/master.bib" ;; where your references are stored
          ivy-bibtex-library-path "~/Documents/mendeley/" ;; where your pdfs etc are stored
          ivy-bibtex-notes-path "~/Dropbox/org/master.org" ;; where your notes are stored
          bibtex-completion-bibliography 'org-ref-default-bibliography ;; writing completion
          bibtex-completion-notes-path "~/Documents/org/master.org")
        (define-key org-mode-map  (kbd "C-c 8") 'ivy-bibtex))
  #+END_SRC 
** Org-ref 
#+BEGIN_SRC emacs-lisp
  (use-package org-ref :after (org ivy)
    :init 
    (setq reftex-default-bibliography '("~/Documents/mendeley/library.bib")
          ;; see org-ref for use of these variables
          org-ref-bibliography-notes "~/Dropbox/org/master.org"
          org-ref-default-bibliography '("~/Documents/mendeley/library.bib")
          org-ref-pdf-directory "~/Documents/mendeley/"
          org-ref-open-pdf-function 'org-ref-get-mendeley-filename
          ;; set ivy for completion
          org-ref-completion-library 'org-ref-ivy-cite)
:config 
            (define-key org-mode-map (kbd "C-c [") 'org-ref-ivy-insert-cite-link)
            (define-key org-mode-map  (kbd "C-c 0") 'org-ref-open-bibtex-notes)
            (define-key org-mode-map  (kbd "C-c 9") 'org-ref-open-notes-from-reftex)
;; define notes template
(defvar org-ref-note-title-fortmat 
  "** %t
[[file:master.org::%t]]
 :PROPERTIES: 
  :Custom_ID: %k
  :AUTHOR: %a
  :JOURNAL: %j
  :YEAR: %y
  :VOLUME: %v 
  :PAGES: %p
  :DOI: %D
  :URL: %U 
  :ADDED:    
:END:")
;; open in different viewer
(setq bibtex-completion-pdf-open-function
  (lambda (fpath)
    (call-process "mendeleydesktop" nil 0 nil fpath))))
#+END_SRC 
**** Fix open-pdf issue
##+BEGIN_SRC emacs-lisp
(defun org-ref-open-bibtex-pdf ()
  (interactive)
  (save-excursion
    (bibtex-beginning-of-entry)
    (let* ((bibtex-expand-strings t)
           (entry (bibtex-parse-entry t))
           (key (reftex-get-bib-field "=key=" entry))
           (pdf (org-ref-get-mendeley-filename key)))
      (message "%s" pdf)
      (if (file-exists-p pdf)
          (org-open-link-from-string (format "[[file:%s]]" pdf))
        (ding)))))
        ##+END_SRC 
**** ivy-bibtex
;; autoload ivy-bibtex
(add-to-list 'load-path "~/.emacs.d/ivy-bibtex/")
(autoload 'ivy-bibtex "ivy-bibtex" "" t)

(setq bibtex-completion-bibliography '("~/Documents/mendeley/master.bib")
         bibtex-completion-library-path '("~/Documents/mendeley/")
         bibtex-completion-pdf-field "file"
         bibtex-completion-notes-path "~/Dropbox/org/master.org"
         bibtex-completion-pdf-symbol "在文"
         bibtex-completion-notes-symbol "筆錄")
****  custom template function
(setq bibtex-completion-notes-template-one-file
      (format
       "\n*** 未 ${title}\n :PROPERTIES:\n :AUTHOR: ${author}\n :YEAR: ${year}\n :Custom_ID: ${=key=}\n :END:\n"))
(setq org-ref-notes-function
      (lambda (thekey)
        (let ((bibtex-completion-bibliography (org-ref-find-bibliography)))
          (bibtex-completion-edit-notes
           (list (car (org-ref-get-bibtex-key-and-file thekey)))))))
(add-hook 'org-mode-hook
          (lambda ()
            (define-key org-mode-map  (kbd "C-c 9") 'org-ref-open-notes-at-point)))
**** 疑 custom notes function

** Yasnippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet :defer t 
  :commands (yas-minor-mode) ; autoload `yasnippet' when `yas-minor-mode' is called
                                        ; using any means: via a hook or by user
                                        ; Feel free to add more commands to this
                                        ; list to suit your needs.
  :init ; stuff to do before requiring the package
(add-hook 'LaTeX-mode-hook #'yas-minor-mode)
(add-hook 'org-mode-hook #'yas-minor-mode)
(add-hook 'bibtex-mode-hook #'yas-minor-mode)
  :config ; stuff to do after requiring the package
(progn
    (yas-reload-all)
;; annoying warning
(add-to-list 'warning-suppress-types '(yasnippet backquote-change))))
#+END_SRC
** Neotree
(require 'neotree)
;; (global-set-key [f6] 'neotree-toggle)

;; theme config
(setq neo-theme (if (display-graphic-p) 'icons 'arrow))

;; show neotree on startup
;; (neotree-show)

;; Every time when the neotree window is opened, let it find current file and jump to node.
(setq neo-smart-open t)

;; When running ‘projectile-switch-project’ (C-c p p), ‘neotree’ will change root automatically.
(setq projectile-switch-project-action 'neotree-projectile-action)

;; Similar to find-file-in-project, NeoTree can be opened (toggled) at projectile project root as follows:
 (defun neotree-project-dir ()
    "Open NeoTree using the git root."
    (interactive)
    (let ((project-dir (projectile-project-root))
          (file-name (buffer-file-name)))
      (neotree-toggle)
      (if project-dir
          (if (neo-global--window-exists-p)
              (progn
                (neotree-dir project-dir)
                (neotree-find file-name)))
        (message "Could not find git project root."))))

;; remap last function
;;(global-set-key [f6] 'neotree-project-dir)

;;(add-hook 'neotree-mode-hook
 ;;   (lambda ()
  ;;    (define-key evil-normal-state-local-map (kbd "q") 'neotree-hide)
   ;;   (define-key evil-normal-state-local-map (kbd "I") 'neotree-hidden-file-toggle)
    ;;  (define-key evil-normal-state-local-map (kbd "z") 'neotree-stretch-toggle)
    ;;  (define-key evil-normal-state-local-map (kbd "R") 'neotree-refresh)
     ;; (define-key evil-normal-state-local-map (kbd "m") 'neotree-rename-node)
      ;;(define-key evil-normal-state-local-map (kbd "c") 'neotree-create-node)
      ;;(define-key evil-normal-state-local-map (kbd "d") 'neotree-delete-node)
      ;;(define-key evil-normal-state-local-map (kbd "s") 'neotree-enter-vertical-split)
      ;;(define-key evil-normal-state-local-map (kbd "S") 'neotree-enter-horizontal-split)
      ;;(define-key evil-normal-state-local-map (kbd "RET") 'neotree-enter))))
** Anzu
#+BEGIN_SRC emacs-lisp
  (use-package anzu  :defer 5
    :config 
(progn
(global-anzu-mode)
            (setq-default anzu-mode-line-update-function
                          'spaceline-all-the-icons-anzu-update-func)))
#+END_SRC 
** Smooth scrolling
#+BEGIN_SRC emacs-lisp
  (use-package smooth-scrolling :defer t
  :config
  (progn
  (smooth-scrolling-mode 1)
  (setq smooth-scroll-margin 5)))
#+END_SRC      
*** change behavior of org movent
#+BEGIN_SRC emacs-lisp
;(setq org-special-ctrl-a/e t)
#+END_SRC 
*** useful scrolling things
#+BEGIN_SRC emacs-lisp
(defun gcm-scroll-down ()
   (interactive)
   (scroll-up 1))

(global-set-key (kbd "M-j") 'gcm-scroll-down)

(defun gcm-scroll-up ()
   (interactive)
   (scroll-down 1))

(global-set-key (kbd "M-k") 'gcm-scroll-up)
#+END_SRC 
** 取 Company mode
(require 'company)

(add-hook 'after-init-hook 'global-company-mode)

;; Don't enable company-mode in below major modes, OPTIONAL
(setq company-global-modes '(not eshell-mode comint-mode erc-mode rcirc-mode))

;; "text-mode" is a major mode for editing files of text in a human language"
;; most major modes for non-programmers inherit from text-mode
(defun text-mode-hook-setup ()
  ;; make `company-backends' local is critcal
  ;; or else, you will have completion in every major mode, that's very annoying!
  (make-local-variable 'company-backends)


(setq company-ispell-available t) ; error without this

  ;; company-ispell is the plugin to complete words
(add-to-list 'company-backends 'company-ispell)

;; OPTIONAL, if `company-ispell-dictionary' is nil, `ispell-complete-word-dict' is used
;; but I prefer hard code the dictionary path. That's more portable.
(setq company-ispell-dictionary (file-truename "~/.emacs.d/dictionaries/francais.txt")))


(add-hook 'text-mode-hook 'text-mode-hook-setup)

(defun toggle-company-ispell ()
  (interactive)
  (cond
   ((memq 'company-ispell company-backends)
    (setq company-backends (delete 'company-ispell company-backends))
    (message "company-ispell disabled"))
   (t
    (add-to-list 'company-backends 'company-ispell)
    (message "company-ispell enabled!"))))

;; skip the downcase that company does to the variables I autocomplete
(setq company-dabbrev-downcase 0)

;; time it takes before company begins completing
(setq company-idle-delay 0.1)
;;(setq company-selection-wrap-around t)
(define-key company-active-map [tab] 'company-complete)
;;(define-key company-active-map (kbd "M-j") 'company-select-next)
;;(define-key company-active-map (kbd "M-k") 'company-select-previous)
;;(add-hook 'company-mode-hook
 ;;           (lambda ()
   ;;           (define-key evil-insert-state-local-map (kbd "TAB") 'company-complete)
     ;;         (define-key evil-insert-state-local-map (kbd "C-j") 'company-select-next)
       ;;       (define-key evil-insert-state-local-map (kbd "C-k") 'company-select-previous)))

;; avoid conflict with yasnippet 
(advice-add 'company-complete-common :before (lambda () (setq my-company-point (point))))
(advice-add 'company-complete-common :after (lambda ()
  		  				(when (equal my-company-point (point))
  			  			  (yas-expand))))
** Solaire mode
#+BEGIN_SRC emacs-lisp
(use-package solaire-mode  :after doom-themes 
  :init ; stuff to do before requiring the package
  (progn
;; brighten buffers (that represent real files)
(add-hook 'after-change-major-mode-hook #'turn-on-solaire-mode)
;; To enable solaire-mode unconditionally for certain modes:
(add-hook 'ediff-prepare-buffer-hook #'solaire-mode)
;; ...if you use auto-revert-mode, this prevents solaire-mode from turning
;; itself off every time Emacs reverts the file
(add-hook 'after-revert-hook #'turn-on-solaire-mode)
;; highlight the minibuffer when it is activated:
(add-hook 'minibuffer-setup-hook #'solaire-mode-in-minibuffer))
;; if the bright and dark background colors are the wrong way around, use this
;; to switch the backgrounds of the `default` and `solaire-default-face` faces.
;; This should be used *after* you load the active thème!
  :config ; stuff to do after requiring the package
;; NOTE: This is necessary for themes in the doom-themes package!
(solaire-mode-swap-bg))
#+END_SRC 
** Nlinum
#+BEGIN_SRC emacs-lisp
  ;;   (defvar doom-line-numbers-style t
  ;;     "The style to use for the line number display.
  ;;   Accepts the same arguments as `display-line-numbers', which are:
  ;;   nil         No line numbers
  ;;   t           Ordinary line numbers
  ;;   'relative   Relative line numbers")

  ;;   (defun doom|enable-line-numbers (&optional arg)
  ;;     "Enables the display of line numbers, using `display-line-numbers' (in Emacs
  ;;   26+) or `nlinum-mode'.
  ;;   See `doom-line-numbers-style' to control the style of line numbers to display."
  ;;     (cond ((boundp 'display-line-numbers)
  ;;            (setq display-line-numbers
  ;;                  (pcase arg
  ;;                    (+1 doom-line-numbers-style)
  ;;                    (-1 nil)
  ;;                    (_ doom-line-numbers-style))))
  ;;           ((eq doom-line-numbers-style 'relative)
  ;;            (if (= arg -1)
  ;;                (nlinum-relative-off)
  ;;              (nlinum-relative-on)))
  ;;           ((not (null doom-line-numbers-style))
  ;;            (nlinum-mode (or arg +1)))))

  ;;   (defun doom|disable-line-numbers ()
  ;;     "Disable the display of line numbers."
  ;;     (doom|enable-line-numbers -1))

  ;;   (add-hook! (prog-mode text-mode conf-mode) #'doom|enable-line-numbers)

  ;;   ;; Emacs 26+ has native line number support.
  ;;   ;; Line number column. A faster (or equivalent, in the worst case) line number
  ;;   ;; plugin than `linum-mode'.
  ;;   (use-package nlinum
  ;;     :unless (boundp 'display-line-numbers)
  ;;     :commands nlinum-mode
  ;;     :init
  ;;     (defvar doom-line-number-lpad 4
  ;;       "How much padding to place before line numbers.")
  ;;     (defvar doom-line-number-rpad 1
  ;;       "How much padding to place after line numbers.")
  ;;     (defvar doom-line-number-pad-char 32
  ;;       "Character to use for padding line numbers.
  ;;   By default, this is a space character. If you use `whitespace-mode' with
  ;;   `space-mark', the whitespace in line numbers will be affected (this can look
  ;;   ugly). In this case, you can change this to ?\u2002, which is a unicode
  ;;   character that looks like a space that `whitespace-mode' won't affect.")
  ;;     :config
  ;;     (setq nlinum-highlight-current-line t)

  ;;     ;; Fix lingering hl-line overlays (caused by nlinum)
  ;;     (add-hook! 'hl-line-mode-hook
  ;;       (remove-overlays (point-min) (point-max) 'face 'hl-line))

  ;;     (defun doom-nlinum-format-fn (line _width)
  ;;       "A more customizable `nlinum-format-function'. See `doom-line-number-lpad',
  ;;   `doom-line-number-rpad' and `doom-line-number-pad-char'. Allows a fix for
  ;;   `whitespace-mode' space-marks appearing inside the line number."
  ;;       (let ((str (number-to-string line)))
  ;;         (setq str (concat (make-string (max 0 (- doom-line-number-lpad (length str)))
  ;;                                        doom-line-number-pad-char)
  ;;                           str
  ;;                           (make-string doom-line-number-rpad doom-line-number-pad-char)))
  ;;         (put-text-property 0 (length str) 'face
  ;;                            (if (and nlinum-highlight-current-line
  ;;                                     (= line nlinum--current-line))
  ;;                                'nlinum-current-line
  ;;                              'linum)
  ;;                            str)
  ;;         str))
  ;;     (setq nlinum-format-function #'doom-nlinum-format-fn)

  ;; (defun doom*nlinum-flush (_ &optional norecord)
  ;;   ;; norecord check is necessary to prevent infinite recursion
  ;;   (when (and nlinum-mode (not norecord))
  ;;     (nlinum--flush)))
  ;; ;; refresh when switching windows
  ;; (advice-add #'select-window :after #'doom*nlinum-flush)
  ;; ;; when pressing esc in normal mode (if you're an evil user)
  ;; (advice-add #'evil-force-normal-state :after #'nlinum--flush)

  ;;     (defun doom|init-nlinum-width ()
  ;;       "Calculate line number column width beforehand (optimization)."
  ;;       (setq nlinum--width
  ;;             (length (save-excursion (goto-char (point-max))
  ;;                                     (format-mode-line "%l")))))
  ;;     (add-hook 'nlinum-mode-hook #'doom|init-nlinum-width))

  ;;   ;; (use-package nlinum  
  ;;   ;; :config 
  ;;   ;; (progn
  ;;   ;; (setq nlinum-highlight-current-line t)
  ;;   ;; (setq nlinum-format "%d  ")
  ;;   ;; (add-hook 'org-mode-hook '(lambda () (nlinum-mode t)))))
#+END_SRC 
** Nlinum hl 
#+BEGIN_SRC emacs-lisp
  ;; (use-package nlinum-hl  :after nlinum
  ;; :config
  ;; ;; Changing fonts can leave nlinum line numbers in their original size; this
  ;; ;; forces them to resize.
  ;; (advice-add #'set-frame-font :after #'nlinum-hl-flush-all-windows))
 #+END_SRC 
** Hl-line mode
#+BEGIN_SRC emacs-lisp
    ;; (use-package hl-line-mode  :after nlinum
    ;; :commands global-hl-line-mode
    ;; :config
    ;; (global-hl-line-mode 1))

  (use-package hl-line ; built-in
    :hook ((text-mode conf-mode) . hl-line-mode)
    :config
    ;; I don't need hl-line showing in other windows. This also offers a small
    ;; speed boost when buffer is displayed in multiple windows.
    (setq hl-line-sticky-flag nil
          global-hl-line-sticky-flag nil)

    ;; On Emacs 26+, when point is on the last line, hl-line highlights bleed into
    ;; the rest of the window after eob. This is the fix.
    ;; (when (boundp 'display-line-numbers)
    ;;   (defun doom--line-range ()
    ;;     (cons (line-beginning-position)
    ;;           (cond ((save-excursion
    ;;                    (goto-char (line-end-position))
    ;;                    (and (eobp) (not (bolp))))
    ;;                  (1- (line-end-position)))
    ;;                 ((or (eobp) (save-excursion (forward-line) (eobp)))
    ;;                  (line-end-position))
    ;;                 (t
    ;;                  (line-beginning-position 2)))))
    ;;   (setq hl-line-range-function #'doom--line-range))

    (after! evil
      (defvar-local doom-buffer-hl-line-mode nil)

      ;; Disable `hl-line' in evil-visual mode (temporarily). `hl-line' can make
      ;; the selection region harder to see while in evil visual mode.
      (defun doom|disable-hl-line ()
        (when hl-line-mode
          (setq doom-buffer-hl-line-mode t)
          (hl-line-mode -1)))
      (defun doom|enable-hl-line-maybe ()
        (if doom-buffer-hl-line-mode (hl-line-mode +1)))

      (add-hook 'evil-visual-state-entry-hook #'doom|disable-hl-line)
      (add-hook 'evil-visual-state-exit-hook  #'doom|enable-hl-line-maybe)))
#+END_SRC 
** Smartparens 
#+BEGIN_SRC emacs-lisp
    ;; Auto-close delimiters and blocks as you type
  (use-package smartparens
    :hook (emacs-startup . smartparens-global-mode)
    :config
    (require 'smartparens-config)

    (setq sp-autowrap-region nil ; let evil-surround handle this
          sp-highlight-pair-overlay nil
          sp-cancel-autoskip-on-backward-movement nil
          sp-show-pair-delay 0
          sp-max-pair-length 3)

    ;; disable smartparens in evil-mode's replace state (they conflict)
    (add-hook 'evil-replace-state-entry-hook #'turn-off-smartparens-mode)
    (add-hook 'evil-replace-state-exit-hook  #'turn-on-smartparens-mode)
  )
    ;; (sp-local-pair '(xml-mode nxml-mode php-mode) "<!--" "-->"
    ;;                :post-handlers '(("| " "SPC"))))
  #+END_SRC 
** Highlight changes mode
#+BEGIN_SRC emacs-lisp
    ;; higlight changes in documents
  (global-highlight-changes-mode t)
  (setq highlight-changes-visibility-initial-state nil); initially hide
  ; toggle visibility
  ;; (global-set-key (kbd "<f7>")      'highlight-changes-visible-mode) ;; changes
  ;; remove the change-highlight in region
  ;;(global-set-key (kbd "S-<f7>")    'highlight-changes-remove-highlight)

  ;; alt-pgup/pgdown jump to the previous/next change

  ;; if you're not already using it for something else...
  (global-set-key (kbd "M->") 'highlight-changes-next-change)
  (global-set-key (kbd "M-<")  'highlight-changes-previous-change)

  ;;(set-face-foreground 'highlight-changes nil)
  (set-face-foreground 'highlight-changes "#268bd2")
  ;;(set-face-background 'highlight-changes "#382f2f")
  (set-face-background 'highlight-changes nil)
  ;;(set-face-foreground 'highlight-changes-delete nil)
  (set-face-foreground 'highlight-changes-delete "#dc322f")
  ;;(set-face-background 'highlight-changes-delete "#916868")
  (set-face-background 'highlight-changes-delete nil)
  #+END_SRC 
** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
  ;; bind a quick and dirty shortcut to 
   (("C-x g" . magit-status)
;;  bind the popup of popus
   ("C-x M-g" . magit-dispatch-popup)))
  #+END_SRC 
** Org-gcal
#+BEGIN_SRC emacs-lisp
(use-package org-gcal :defer t :after org 
:init
(setq org-gcal-client-id "478680381907-rdq488vt3kdutlt1a32sajihog95iuo2.apps.googleusercontent.com"
	org-gcal-client-secret "EsCu2Ikaga6TIa0KVpZ9jRTS"
	org-gcal-file-alist '(("cantorlunae@gmail.com" .  "~/Dropbox/org/gcal.org")
("uv89i0rlnv503i17nedvmo95f8@group.calendar.google.com" . "~/Dropbox/org/unterrichte.org")
("c83agj55j9uipbjdd2mmp7h9v8@group.calendar.google.com" . "~/Dropbox/org/ereignisse.org")
("ekk7658f3jm5fh1mea2sdnu8vc@group.calendar.google.com" . "~/Dropbox/org/gewohnheiten.org")
("#contacts@group.v.calendar.google.com" . "~/Dropbox/org/jahrestage.org")
;;("#contacts@group.v.calendar.google.com" . "~/Dropbox/org/jahrestage.org")
)))

;;(add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync) ))
;;(add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-sync) ))
#+END_SRC 
** Calendar
#+BEGIN_SRC emacs-lisp
(setq calendar-date-style 'european ; format jour/mois/an
      european-calendar-style 't
      calendar-week-start-day 7     ; week starts on monday
      calendar-day-name-array     ["Dimanche" "Lundi" "Mardi" "Mercredi" "Jeudi" "Vendredi" "Samedi"]
      calendar-day-abbrev-array   ["dim" "lun" "mar" "mer" "jeu" "ven" "sam"]
      calendar-month-name-array   ["Janvier" "Février" "Mars" "Avril" "Mai" "Juin" "Juillet"
                                   "Août" "Septembre" "Octobre" "Novembre" "Décembre"]
      calendar-month-abbrev-array ["jan" "fév" "mar" "avr" "mai" "jun" "jul" "aoû" "sep" "oct" "nov" "déc"])

(eval-when-compile
  (require 'calendar)
  (require 'holidays))

(defvar holiday-french-holidays nil
  "French holidays")

(setq calendar-holidays
      '(;; fetes a date variable
	(holiday-easter-etc 0 "Pâques")
        (holiday-easter-etc 1 "Lundi de Pâques")
        (holiday-easter-etc 39 "Ascension")
        (holiday-easter-etc 49 "Pentecôte")
        (holiday-easter-etc -47 "Mardi gras")))
#+END_SRC 
** Calfw
#+BEGIN_SRC emacs-lisp
(require 'calfw)
;;(require 'calfw-gcal)
;;(require 'calfw-cal)
(require 'calfw-org)


(defun my-open-calendar ()
    (interactive)
    (let ((buf (get-buffer "*cfw-calendar*")))
      (if buf
          (pop-to-buffer buf nil)
        (cfw:open-calendar-buffer
         :contents-sources
         (list (cfw:org-create-source "#c0c5ce")
;               (cfw:cal-create-source "Dark Orange")
)
         :view 'week))))

;; keybinding
(global-set-key (kbd "<f7>") 'my-open-calendar)
(define-key cfw:details-mode-map (kbd "SPC") 'cfw:details-kill-buffer-command)

 ;;(global-set-key (kbd "<f7>") 'cfw:open-org-calendar)

  (setq cfw:fchar-junction ?╋
        cfw:fchar-vertical-line ?┃
        cfw:fchar-horizontal-line ?━
        cfw:fchar-left-junction ?┣
        cfw:fchar-right-junction ?┫
        cfw:fchar-top-junction ?┯
        cfw:fchar-top-left-corner ?┏
        cfw:fchar-top-right-corner ?┓)
#+END_SRC 
** Alert (Growl) 
#+BEGIN_SRC emacs-lisp
(use-package alert :load-path "~/.emacs.d/sync0_git/alert" :defer t)
#+END_SRC 
** Powerline
#+BEGIN_SRC emacs-lisp
  (use-package powerline
  :if window-system
  :config (setq-default powerline-default-separator 'nil))
  #+END_SRC 
** Foreign languages
*** Foreign language setup
**** English
#+BEGIN_SRC emacs-lisp
  ;; (defun sync0-toggle-off-input-method ()
  ;;   (interactive)
  ;;   (if current-input-method (deactivate-input-method)))

    (defun sync0-english-keyboard-setup ()
      "Set input methods for EVIL mode suitable for French"
      ;; check whether EVIL mode is active
      (when (bound-and-true-p evil-mode) 
        ;; TeX for evil insert mode 
        (add-hook 'evil-insert-state-entry-hook 
                  (lambda () (set-input-method nil)))
        ;; TeX for evil replace mode
        (add-hook 'evil-replace-state-entry-hook
                  (lambda () (set-input-method nil)))))
  #+END_SRC 
**** French
#+BEGIN_SRC emacs-lisp
  (defun sync0-french-keyboard-setup ()
    "Set input methods for EVIL mode suitable for French"
    ;; check whether EVIL mode is active
    (when (bound-and-true-p evil-mode) 
      ;; french-postfix for evil insert mode 
      (add-hook 'evil-insert-state-entry-hook 
                (lambda () (set-input-method "french-postfix")))
      ;; french-postfix for evil replace mode
      (add-hook 'evil-replace-state-entry-hook
                (lambda () (set-input-method "french-postfix")))))
  #+END_SRC 
*** Rabelais-mode
#+BEGIN_SRC emacs-lisp
  (defvar sync0-language-active 
    "Is a human language minor mode enabled?")

  (define-minor-mode rabelais-mode
    "Get your foos in the right places."
;; The initial value.
 :init-value nil
;; The indicator for the mode line.
    :lighter " rabelais"
;; Make it a global minor mode. 
    :global  t
    (when (bound-and-true-p orwell-mode) 
      (add-hook 'text-mode-hook (lambda () (orwell-mode -1))))
    (setq sync0-language-active 'Rabelais
          local-abbrev-table rabelais-mode-abbrev-table)
    (sync0-french-keyboard-setup)
    (ispell-change-dictionary "fr_FR")
     (add-to-list 'minor-mode-alist '(rabelais-mode " rabelais"))
    (abbrev-mode 1))
  #+END_SRC 
*** Orwell-mode
#+BEGIN_SRC emacs-lisp
  (define-minor-mode orwell-mode
    "Get your foos in the right places."
;; The initial value.
 :init-value nil
;; The indicator for the mode line.
    :lighter " orwell"
;; Make it a global minor mode. 
    :global  t
    (when (bound-and-true-p rabelais-mode) 
      (add-hook 'text-mode-hook (lambda () (rabelais-mode -1))))
    (setq sync0-language-active 'Orwell
          local-abbrev-table orwell-mode-abbrev-table)
    (sync0-english-keyboard-setup)
    (ispell-change-dictionary "en_US-large")
     (add-to-list 'minor-mode-alist '(orwell-mode " orwell"))
    (abbrev-mode 1))
  #+END_SRC 
*** Marquez-mode
  (defun marquez-mode ()
  "Major mode for editing englisch written for humans to read.
In this mode, paragraphs are delimited only by blank or white lines.
You can thus get the full benefit of adaptive filling
 (see the variable `adaptive-fill-mode').
\\{englisch-mode-map}
Turning on Text mode runs the normal hook `englisch-mode-hook'."
  (interactive)
  (setq local-abbrev-table marquez-mode-abbrev-table)
  (setq mode-name "Marquez")
  (setq minor-mode 'marquez-mode)
  (ispell-change-dictionary "es_CO")
  ;;(setq common-abbrevs-list 'common-english-abbrevs)
  (abbrev-mode 1)
  (run-hooks 'marquez-mode-hook))
*** Spaceline segment
#+BEGIN_SRC emacs-lisp
  ;; (defun sync0-language-segment (sync0-language-active)
  ;;   "Display active human language minor mode."
  ;;   (when (equal sync0-language-active 1)
  ;;     (cond ((bound-and-true-p orwell-mode) 
  ;;            (propertize (format "Orwell") 'face `(:height ,(spaceline-all-the-icons--height 0.9) :inherit) 'display '(raise 0.1)))
  ;;     ((bound-and-true-p rabelais-mode)
  ;;      (propertize (format "Rabelais") 'face `(:height ,(spaceline-all-the-icons--height 0.9) :inherit) 'display '(raise 0.1)))
  ;;     )))

  ;; (defun sync0-language-segment (sync0-language-active)
  ;;   "Display active human language minor mode."
  ;;   (when (boundp 'sync0-language-active)
  ;;            (format "%s" sync0-language-active))) 

  (defun sync0-language-segment (sync0-language-active)
    "Display active human language minor mode."
    (when (boundp 'sync0-language-active)
              (propertize (format "%s" sync0-language-active) 'face `(:height ,(spaceline-all-the-icons--height 0.9) :inherit) 'display '(raise 0.1))))

  ;; (spaceline-define-segment sync0-language-segment
  ;;   "Inform wheter a human language mode is on"
  ;;   (if (equal 'sync0-language-active 1)
  ;;       (progn
  ;;         (when (and active (bound-and-true-p orwell-mode)
  ;;                    (propertize "Orwell" 'face 'bold)))
  ;;         (when (and active (bound-and-true-p rabelais-mode)
  ;;                    (propertize "Rabelais" 'face 'bold))))
  ;;     (propertize "無語" 'face 'bold))))
  #+END_SRC 
** Spaceline
#+BEGIN_SRC emacs-lisp
    (use-package spaceline :after powerline
     :config 
  (setq spaceline-responsive nil))
    ;; (use-package spaceline-colors :after spaceline-all-the-icons :load-path "init/spaceline-colors"
    ;;   :config (advice-add 'load-theme :after 'spaceline-update-faces))

    ;; (spaceline-define-segment sync0-language-segment
    ;;   "Inform wheter a human language mode is on"
    ;;   (if (equal 'sync0-language-active 1)
    ;;       (progn
    ;;         (when (and active (bound-and-true-p orwell-mode)
    ;;                    (propertize "Orwell" 'face 'bold)))
    ;;         (when (and active (bound-and-true-p rabelais-mode)
    ;;                    (propertize "Rabelais" 'face 'bold))))
    ;;     (propertize "無語" 'face 'bold))))

    (use-package spaceline-all-the-icons
      :after spaceline
      :config
      (progn
        (setq spaceline-all-the-icons-icon-set-bookmark 'heart
              spaceline-all-the-icons-icon-set-modified 'toggle
              spaceline-all-the-icons-icon-set-dedicated 'pin
              ;;        spaceline-all-the-icons-icon-set-flycheck-slim 'dots
              ;;         spaceline-all-the-icons-flycheck-alternate t
              spaceline-all-the-icons-highlight-file-name t
              spaceline-all-the-icons-hide-long-buffer-path t)
        (spaceline-toggle-all-the-icons-bookmark-on)
        (spaceline-toggle-all-the-icons-dedicated-on)
        ;; (spaceline-toggle-all-the-icons-fullscreen-on)
        ;;(spaceline-toggle-all-the-icons-buffer-position-on)
        (spaceline-all-the-icons--setup-anzu)
        ;;    (spaceline-all-the-icons--setup-package-updates)
        ;;(spaceline-all-the-icons--setup-paradox)
        ;;  (spaceline-all-the-icons--setup-neotree)
        (spaceline-all-the-icons-theme 'sync0-language-segment)))
        ;; (spaceline-all-the-icons-theme)))
  #+END_SRC 
** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
  ;; In case I later need to wrap defhydra in any special functionality.
  :config
  (setq lv-use-seperator t))
#+END_SRC 
** Diff-hl
#+BEGIN_SRC emacs-lisp
  ;;   (use-package diff-hl
  ;;   :init
  ;;   (progn
  ;;     (setq diff-hl-side 'left
  ;;           diff-hl-margin-symbols-alist
  ;;           '((insert . "+") (delete . "-") (change . "~")
  ;;             (unknown . "?") (ignored . "i")))
  ;; ;; Better looking colours for diff indicators /w spacemacs-light theme
  ;;   ;; (custom-set-faces
  ;;   ;; '(diff-hl-change ((t (:background "#3a81c3"))))
  ;;   ;; '(diff-hl-insert ((t (:background "#7ccd7c"))))
  ;;   ;; '(diff-hl-delete ((t (:background "#ee6363")))))
  ;;     (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh)
  ;;     ;;(diff-hl-flydiff-mode)
  ;;   ;;  (diff-hl-margin-mode)
  ;;     (global-diff-hl-mode)))
  #+END_SRC 
** Avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :after evil
    :commands (avy-goto-char-2 avy-goto-line avy-org-goto-heading-timer)
    :init
    (evil-define-key 'normal org-mode-map
      "gl" 'avy-goto-line
      "gc" 'avy-goto-char-2
      "go" 'avy-org-goto-heading-timer
      "gr" 'avy-org-refile-as-child)
    :config
    (setq avy-all-windows nil
          avy-background t))
  #+END_SRC 
** Gît-gutter 
#+BEGIN_SRC emacs-lisp
          (use-package git-gutter
            :after hydra 
            :commands git-gutter-mode
            :hook (text-mode . git-gutter-mode)
            :config
      ;; (setq-default left-fringe-width  10)
      ;; (setq-default right-fringe-width 10)
              (setq 
             ;  git-gutter:window-width 1
               git-gutter:modified-sign " " ;; two space
                git-gutter:added-sign " "    ;; multiple character is OK
                git-gutter:deleted-sign " ")


    ;;(set-face-background 'git-gutter:modified "orange") ;; background color
    (set-face-background 'git-gutter:modified "#3a81c3") ;; background color
    ;;(set-face-background 'git-gutter:added "green")
    (set-face-background 'git-gutter:added "#7ccd7c")
   ;; (set-face-attribute  'git-gutter:added nil :foreground "black")
    ;;(set-face-background 'git-gutter:deleted "red")
    (set-face-background 'git-gutter:deleted "ee6363")
  ;;  (set-face-attribute  'git-gutter:deleted nil :foreground "black")

     (after!  evil
        (defun +version-control|update-git-gutter ()
          "Refresh git-gutter on ESC. Return nil to prevent shadowing other
    `+evil-esc-hook' hooks."
          (when git-gutter-mode
            (ignore (git-gutter))))
        (add-hook '+evil-esc-hook #'+version-control|update-git-gutter t))

            (defhydra hydra-git-gutter
              (:body-pre (git-gutter-mode 1) :hint nil)
              "
                                                         ╭─────────────────┐
                      Movement   Hunk Actions     Misc.  │ gg: +%-4s(car (git-gutter:statistic))/ -%-3s(cdr (git-gutter:statistic)) │
                      ╭──────────────────────────────────┴─────────────────╯
                         ^_g_^       [_s_] stage        [_R_] set start Rev
                         ^_k_^       [_r_] revert
                         ^↑ ^      [_m_] mark
                         ^↓ ^      [_p_] popup          ╭──────────────────────
                         ^_j_^                          │[_q_] quit
                         ^_G_^                          │[_Q_] Quit and disable"
              ("j" (progn (git-gutter:next-hunk 1) (recenter)))
              ("k" (progn (git-gutter:previous-hunk 1) (recenter)))
              ("g" (progn (goto-char (point-min)) (git-gutter:next-hunk 1)))
              ("G" (progn (goto-char (point-min)) (git-gutter:previous-hunk 1)))
              ("s" git-gutter:stage-hunk)
              ("r" git-gutter:revert-hunk)
              ("m" git-gutter:mark-hunk)
              ("p" git-gutter:popup-hunk)
              ("R" git-gutter:set-start-revision)
              ("q" nil :color blue)
              ("Q" (git-gutter-mode -1) :color blue)))
  #+END_SRC 
** EasyPG
#+BEGIN_SRC emacs-lisp
  (require 'epa-file)
(epa-file-enable)
  #+END_SRC 
* Custom Functions
** Sentence highlight
#+BEGIN_SRC emacs-lisp
  (use-package sentence-highlight :load-path "~/.emacs.d/sync0/" 
    :after cycle-themes
    :commands sentence-highlight-mode
    :config 
    (progn
     (set-face-foreground 'sentence-highlight-face "#002b36")
      (defun sync0-change-sentence-highlight-color ()
        "Change the sentence hightlight color based on the doom-theme enabled." 
        (when (boundp 'cycle-themes-last-theme-set)
          (if (equal cycle-themes-last-theme-set 'doom-spacegrey)
            ;; solarized-light
            (set-face-foreground 'sentence-highlight-face "#ECBE7B")
            ;; space-grey
            (set-face-foreground 'sentence-highlight-face "#b48ead"))))

        (add-hook 'cycle-themes-after-cycle-hook #'sync0-change-sentence-highlight-color)))

  ;; (use-package sentence-highlight :load-path "~/.emacs.d/sync0/" 
  ;;   :after cycle-themes
  ;;   :commands sentence-highlight-mode
  ;;   :config 
  ;;   (progn
  ;;     (defun sync0-change-sentence-highlight-color ()
  ;;       "Change the sentence hightlight color based on the doom-theme enabled." 
  ;;       (when (boundp 'cycle-themes-last-theme-set)
  ;;         (when (equal cycle-themes-last-theme-set 'doom-spacegrey)
  ;;           ;; solarized-light
  ;;           (set-face-foreground 'sentence-highlight-face "#002b36")
  ;;           (equal cycle-themes-last-theme-set 'doom-solarized-light')
  ;;           ;; space-grey
  ;;           (set-face-foreground 'sentence-highlight-face "#c0c5ce"))))
  ;;       (add-hook 'cycle-themes-after-cycle-hook 'sync0-change-sentence-highlight-color)))

    ;; (base8      '("#DFDFDF" "#dfdfdf" "white"        ))
    ;; (fg         '("#c0c5ce" "#c0c5ce" "brightwhite"  ))
    ;; (red        '("#BF616A" "#BF616A" "red"          ))
    ;; (orange     '("#D08770" "#D08770" "brightred"    ))
    ;; (green      '("#A3BE8C" "#A3BE8C" "green"        ))
    ;; (blue       '("#8FA1B3" "#8FA1B3" "brightblue"   ))
    ;; (violet     '("#b48ead" "#b48ead" "brightmagenta"))
    ;; (teal       '("#4db5bd" "#44b9b1" "brightgreen"  ))
    ;; (yellow     '("#ECBE7B" "#ECBE7B" "yellow"       ))
    ;; (dark-blue  '("#2257A0" "#2257A0" "blue"         ))
    ;; (magenta    '("#c678dd" "#c678dd" "magenta"      ))
    ;; (cyan       '("#46D9FF" "#46D9FF" "brightcyan"   ))
    ;; (dark-cyan  '("#5699AF" "#5699AF" "cyan"         ))
  #+END_SRC 
** Date
#+BEGIN_SRC emacs-lisp
  (defun insert-current-day () 
    (insert (shell-command-to-string "echo -n $(date +%d)")))

  (defun insert-current-month () 
    (insert (shell-command-to-string "echo -n $(date +%B)")))

(defun sync0-insert-dates ()
  "insert a bunch of dates"
  (interactive)
  (let* ((month 4)
         (day 1)
         (time (encode-time 1 1 0 day month 2019)))
    (while (= (nth 4 (decode-time time)) month)
      (insert (concat "*** " (format-time-string "%d/%m/%Y \n" time)))
      (setq day (1+ day))
      (setq time (encode-time 1 1 0 day month 2019)))))

(defun sync0-insert-weeks ()
  "insert a bunch of weeks"
  (interactive)
  (let* ((weeky 1))
    (while (< weeky 32)
      (insert (format  "** \ordinalnum{%s} Week \n" weeky))
      (setq weeky (1+ weeky)))))
#+END_SRC
** 取 Automatic abbrevs integration with ispell
;;(define-key ctl-x-map "\C-i"
  ;;#'endless/ispell-word-then-abbrev)

(defun endless/simple-get-word ()
  (car-safe (save-excursion (ispell-get-word nil))))

(defun endless/ispell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
  (interactive "P")
  (let (bef aft)
    (save-excursion
      (while (if (setq bef (endless/simple-get-word))
                 ;; Word was corrected or used quit.
                 (if (ispell-word nil 'quiet)
                     nil ; End the loop.
                   ;; Also end if we reach `bob'.
                   (not (bobp)))
               ;; If there's no word at point, keep looking
               ;; until `bob'.
               (not (bobp)))
        (backward-word)
        (backward-char))
      (setq aft (endless/simple-get-word)))
    (if (and aft bef (not (equal aft bef)))
        (let ((aft (downcase aft))
              (bef (downcase bef)))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob")))
      (user-error "No typo at or before point"))))

(setq save-abbrevs 'silently)
(setq-default abbrev-mode t)

;; set a faster shortcut
(define-key global-map (kbd "M-i") 'endless/ispell-word-then-abbrev)
** Automatic abbrevs integration with ispell
#+BEGIN_SRC emacs-lisp
;;(define-key ctl-x-map "\C-i"
  ;;#'endless/ispell-word-then-abbrev)

(defun endless/simple-get-word ()
  (car-safe (save-excursion (ispell-get-word nil))))

(defun endless/ispell-word-then-abbrev ()
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
  (interactive)
  (let (bef aft)
    (save-excursion
      (while (if (setq bef (endless/simple-get-word))
                 ;; Word was corrected or used quit.
                 (if (ispell-word nil 'quiet)
                     nil ; End the loop.
                   ;; Also end if we reach `bob'.
                   (not (bobp)))
               ;; If there's no word at point, keep looking
               ;; until `bob'.
               (not (bobp)))
        (backward-word)
        (backward-char))
      (setq aft (endless/simple-get-word)))
    (if (and aft bef (not (equal aft bef)))
        (let ((aft (downcase aft))
              (bef (downcase bef)))
          (define-abbrev local-abbrev-table bef aft)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft "loc"))
      (user-error "No typo at or before point"))))

(setq save-abbrevs 'silently)
(setq-default abbrev-mode t)

;; set a faster shortcut
(define-key global-map (kbd "M-i") 'endless/ispell-word-then-abbrev)
#+END_SRC 
** Latex changes mode
  (defvar sync0-language-active 0
    "Is a human language minor mode enabled?")


(evil-define-operator sync0-latex-changes-evil-delete (beg end type register yank-handler)
  "Delete text from BEG to END with TYPE.
Save in REGISTER or in the kill-ring with YANK-HANDLER."
  (interactive "<R><x><y>")
  (unless register
    (let ((text (filter-buffer-substring beg end)))
      (unless (string-match-p "\n" text)
        ;; set the small delete register
        (evil-set-register ?- text))))
  (let ((evil-was-yanked-without-register nil))
    (evil-yank beg end type register yank-handler))
  (cond
   ((eq type 'block)
    (evil-apply-on-block #'delete-region beg end nil))
   ((and (eq type 'line)
         (= end (point-max))
         (or (= beg end)
             (/= (char-before end) ?\n))
         (/= beg (point-min))
         (=  (char-before beg) ?\n))
    (delete-region (1- beg) end))
   (t
    (delete-region beg end)))
  ;; place cursor on beginning of line
  (when (and (called-interactively-p 'any)
             (eq type 'line))
    (evil-first-non-blank)))


  (define-minor-mode sync0-latex-changes-mode
    "Get your foos in the right places."
;; The initial value.
 :init-value nil
;; The indicator for the mode line.
    :lighter " rabelais"
;; Make it a global minor mode. 
    :global  t
    (when (bound-and-true-p orwell-mode) 
      (add-hook 'text-mode-hook (lambda () (orwell-mode -1))))
    (setq sync0-language-active 1
          local-abbrev-table rabelais-mode-abbrev-table)
    (sync0-french-keyboard-setup)
    (ispell-change-dictionary "fr_FR")
     (add-to-list 'minor-mode-alist '(rabelais-mode " rabelais"))
    (abbrev-mode 1))
* Useful Key Bindings
** Font size change
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "C-+") 'text-scale-increase)
(define-key global-map (kbd "C--") 'text-scale-decrease)
#+END_SRC
** Cycle through buffers
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-tab>") 'bury-buffer)
#+END_SRC
** Load EMACS initialization file
(global-set-key (kbd "C-c i") 
(lambda() (interactive)(org-babel-load-file "~/.emacs.d/emacs_settings.org")))
** Rebind frequent commands
*** Ctrl-<space> to pop-global-mark
 (defun pop-local-or-global-mark ()
  "Pop to local mark if it exists or to the global mark if it does not."
  (interactive)
  (if (mark t)
      (pop-to-mark-command)
      (pop-global-mark)))

;; keybinding
;;(global-set-key (kbd "C-SPC") nil) ;; default bound to set-mark
;;(global-set-key (kbd "C-SPC") 'pop-local-or-global-mark) 
*** Quickly save
#+BEGIN_SRC emacs-lisp
(global-set-key "\M-w" 'save-buffer)
#+END_SRC  
*** Quickly work with bookmarks
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-m") 'bookmark-set)
(global-set-key (kbd "M-b") 'bookmark-jump)
#+END_SRC 
* Backups 
** Store all autosave files in the tmp dir
#+BEGIN_SRC emacs-lisp 
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+END_SRC
** Backups in backup dir
#+BEGIN_SRC emacs-lisp 
(setq backup-by-copying t
      backup-directory-alist '(("." . "~/.emacs.d/backups"))
      delete-old-versions t
      kept-new-versions 10
      kept-old-versions 0
;; use versioned backups
      version-control t)

;; no lockfiles
(setq create-lockfiles nil) 
#+END_SRC
